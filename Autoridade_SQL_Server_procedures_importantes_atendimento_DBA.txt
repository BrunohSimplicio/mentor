
use master
go

SET QUOTED_IDENTIFIER OFF
go

CREATE PROCEDURE sp_Quem  
    @loginame     sysname = NULL  
as  

-- Exibe todos os bloqueios da instancia
-- De www.clouddbm.com Opensource Copywrited by Gilberto Rosa (gilberto.rosa@clouddbm.com)
-- Script executado em mais de 10 mil Bancos de Dados, valide seu ambiente e tenha backup

  
set nocount on  
  
declare  
    @retcode         int  
  
declare  
    @sidlow         varbinary(85)  
   ,@sidhigh        varbinary(85)  
   ,@sid1           varbinary(85)  
   ,@spidlow         int  
   ,@spidhigh        int  
  
declare  
    @charMaxLenLoginName      varchar(6)  
   ,@charMaxLenDBName         varchar(6)  
   ,@charMaxLenCPUTime        varchar(10)  
   ,@charMaxLenDiskIO         varchar(10)  
   ,@charMaxLenHostName       varchar(10)  
   ,@charMaxLenProgramName    varchar(10)  
   ,@charMaxLenLastBatch      varchar(10)  
   ,@charMaxLenCommand        varchar(10)  
  
declare  
    @charsidlow              varchar(85)  
   ,@charsidhigh             varchar(85)  
   ,@charspidlow              varchar(11)  
   ,@charspidhigh             varchar(11)  
  
--------  
  
select  
    @retcode         = 0      -- 0=good ,1=bad.  
  
--------defaults  
select @sidlow = convert(varbinary(85), (replicate(char(0), 85)))  
select @sidhigh = convert(varbinary(85), (replicate(char(1), 85)))  
  
select  
    @spidlow         = 0  
   ,@spidhigh        = 32767  
  
--------------------------------------------------------------  
IF (@loginame IS     NULL)  --Simple default to all LoginNames.  
      GOTO LABEL_17PARM1EDITED  
  
--------  
  
-- select @sid1 = suser_sid(@loginame)  
select @sid1 = null  
if exists(select * from master.dbo.syslogins where loginname = @loginame)  
 select @sid1 = sid from master.dbo.syslogins where loginname = @loginame  
  
IF (@sid1 IS NOT NULL)  --Parm is a recognized login name.  
   begin  
   select @sidlow  = suser_sid(@loginame)  
         ,@sidhigh = suser_sid(@loginame)  
   GOTO LABEL_17PARM1EDITED  
   end  
  
--------  
  
IF (lower(@loginame) IN ('active'))  --Special action, not sleeping.  
   begin  
   select @loginame = lower(@loginame)  
   GOTO LABEL_17PARM1EDITED  
   end  
  
--------  
  
IF (patindex ('%[^0-9]%' , isnull(@loginame,'z')) = 0)  --Is a number.  
   begin  
   select  
             @spidlow   = convert(int, @loginame)  
            ,@spidhigh  = convert(int, @loginame)  
   GOTO LABEL_17PARM1EDITED  
   end  
  
--------  
  
RaisError(15007,-1,-1,@loginame)  
select @retcode = 1  
GOTO LABEL_86RETURN  
  
  
LABEL_17PARM1EDITED:  
  
  
--------------------  Capture consistent sysprocesses.  -------------------  
  
SELECT  
  
  spid  
 ,status  
 ,sid  
 ,hostname  
 ,program_name  
 ,cmd  
 ,cpu  
 ,physical_io  
 ,blocked  
 ,dbid  
 ,convert(sysname, rtrim(loginame))  
        as loginname  
 ,spid as 'spid_sort'  
  
 ,  substring( convert(varchar,last_batch,111) ,6  ,5 ) + ' '  
  + substring( convert(varchar,last_batch,113) ,13 ,8 )  
       as 'last_batch_char'  
  
      INTO    #tb1_sysprocesses  
      from master.dbo.sysprocesses   (nolock)  
      where blocked <> 0  
  
--------Screen out any rows?  
  
IF (@loginame IN ('active'))  
   DELETE #tb1_sysprocesses  
         where   lower(status)  = 'sleeping'  
         and     upper(cmd)    IN (  
                     'AWAITING COMMAND'  
                    ,'MIRROR HANDLER'  
                    ,'LAZY WRITER'  
                    ,'CHECKPOINT SLEEP'  
                    ,'RA MANAGER'  
                                  )  
  
         and     blocked       = 0  
  
  
  
--------Prepare to dynamically optimize column widths.  
  
  
Select  
    @charsidlow     = convert(varchar(85),@sidlow)  
   ,@charsidhigh    = convert(varchar(85),@sidhigh)  
   ,@charspidlow     = convert(varchar,@spidlow)  
   ,@charspidhigh    = convert(varchar,@spidhigh)  
  
  
  
SELECT  
             @charMaxLenLoginName =  
                  convert( varchar  
                          ,isnull( max( datalength(loginname)) ,5)  
                         )  
  
            ,@charMaxLenDBName    =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,db_name(dbid)))) ,6)  
                         )  
  
            ,@charMaxLenCPUTime   =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,cpu))) ,7)  
                         )  
  
            ,@charMaxLenDiskIO    =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,physical_io))) ,6)  
                         )  
  
            ,@charMaxLenCommand  =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,cmd))) ,7)  
                         )  
  
            ,@charMaxLenHostName  =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,hostname))) ,8)  
                         )  
  
            ,@charMaxLenProgramName =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,program_name))) ,11)  
                         )  
  
            ,@charMaxLenLastBatch =  
                  convert( varchar  
                          ,isnull( max( datalength( convert(varchar,last_batch_char))) ,9)  
                         )  
      from  
             #tb1_sysprocesses  
      where  
--             sid >= @sidlow  
--      and    sid <= @sidhigh  
--      and  
             spid >= @spidlow  
      and    spid <= @spidhigh  
  
  
  
--------Output the report.  
  
  
EXECUTE(  
'  
SET nocount off  
  
SELECT  
             SPID          = convert(char(5),spid)  
  
            ,Status        =  
                  CASE lower(status)  
                     When ''sleeping'' Then convert(varchar(12),lower(status))  
                     Else                   convert(varchar(12),upper(status))  
                  END  
  
            ,Login         = convert(varchar(12),loginname)  
  
            ,HostName      =  
                  CASE hostname  
                     When Null  Then ''  .''  
                     When '' '' Then ''  .''  
                     Else    convert(varchar(12),hostname)  
                  END  
  
            ,BlkBy         =  
                  CASE               isnull(convert(char(5),blocked),''0'')  
                     When ''0'' Then ''  .''  
                     Else            isnull(convert(char(5),blocked),''0'')  
                  END  
  
            ,DBName        = convert(varchar(12),db_name(dbid))  
            ,Command       = cmd  
  
            ,ProgramName   = substring(program_name,1,' + @charMaxLenProgramName + ')  
      from  
             #tb1_sysprocesses  --Usually DB qualification is needed in exec().  
      where  
             spid >= ' + @charspidlow  + '  
      and    spid <= ' + @charspidhigh + '  
  
      -- (Seems always auto sorted.)   order by spid_sort  
  
'  
)  
/*****AKUNDONE: removed from where-clause in above EXEC sqlstr  
             sid >= ' + @charsidlow  + '  
      and    sid <= ' + @charsidhigh + '  
      and  
**************/  
  
  
LABEL_86RETURN:  
  
SET     ROWCOUNT     1  
  
DECLARE @DBCCcmd     varchar(250)  
DECLARE @QualSPID    varchar(5)  
DECLARE @QualBlkBy   varchar(5)  
  
SELECT  @QualSPID  = convert(varchar(5),SPID ),  
        @QualBlkBy = convert(varchar(5),Blocked)  
        FROM #tb1_sysprocesses  
  
WHILE @@ROWCOUNT <> 0  
  BEGIN  
   SET     @DBCCcmd = "............................. Comando executado pelo processo BLOQUEADO: " + @QualSPID  
   PRINT   @DBCCcmd  
   EXECUTE ( "dbcc inputbuffer ( " + @QualSPID + " )" )  
   SET     @DBCCcmd = "............................. Comando executado pelo processo BLOQUEANDO: " + @QualBlkBy  
   PRINT   @DBCCcmd  
   EXECUTE ( "dbcc inputbuffer ( " + @QualBlkBy + " )" )  
   DELETE  FROM #tb1_sysprocesses  
   SELECT  @QualSPID= convert(varchar(5),SPID ),  
           @QualBlkBy = convert(varchar(5),Blocked)  
           FROM #tb1_sysprocesses  
  END  
  
SET ROWCOUNT 0  
  
IF (object_id('tempdb..#tb1_sysprocesses') is not null)  
    drop table #tb1_sysprocesses  
  
SET NOCOUNT OFF  
  
return @retcode -- sp_quem  
  
  
  go
 ----------------
use master
go

  CREATE PROCEDURE sp_operador  
AS  

-- Exibe a causa raiz dos bloqueios que devem ser finalizados com cuidado e sob an�lise da causa raiz
-- De www.clouddbm.com Opensource Copywrited by Gilberto Rosa (gilberto.rosa@clouddbm.com)
-- Script executado em mais de 10 mil Bancos de Dados, valide seu ambiente e tenha backup


IF EXISTS  
    (SELECT * FROM master.dbo.sysprocesses (nolock)  
    WHERE spid IN (SELECT blocked FROM master.dbo.sysprocesses (nolock)))  
    SELECT   
        spid, status, loginame=substring(loginame, 1, 12),  
        hostname=substring(hostname, 1, 12),  
            blk=CONVERT(char(3), blocked),  
            open_tran,  
        dbname=substring(db_name(dbid),1,10),cmd,   
            waittype, waittime, last_batch  
        FROM master.dbo.sysprocesses (nolock)  
        WHERE spid IN (SELECT blocked FROM master.dbo.sysprocesses (nolock))  
            AND blocked=0  
ELSE  
SELECT "sem processos bloqueados !"  
  
go
-------------------
go
use master
go


 create procedure sp_executando as   
set nocount on

-- Existe todos os processos em execu��o na instancia sql server
-- De www.clouddbm.com Opensource Copywrited by Gilberto Rosa (gilberto.rosa@clouddbm.com)
-- Script executado em mais de 10 mil Bancos de Dados, valide seu ambiente e tenha backup

  
declare @QualID varchar(5)  
print '....................................................................................................................................'  
print 'Processos com status RUNNABLE !'  
print ''  
create table #tmpProc (spid         varchar(5),  
                       dbname       varchar(15),  
                       hostname     varchar(15),  
                       cpu          integer,  
                       program_name varchar(35),  
                       nt_username  varchar(15),  
                       mem_usage    integer,  
                       cmd          varchar(30),  
                       LoginName    varchar(15),  
                       hostprocess  integer )  
  
insert into #tmpProc  
select convert(varchar(5),spid), convert(varchar(15),db_name(dbid)) Database_Name,    
       convert(varchar(15),hostname) Hostname, cpu,  
       convert(varchar(35),program_name) Program_Name,   
       convert(varchar(15),nt_username) NT_Username, memusage, cmd, convert(varchar(15),loginame) LoginName,hostprocess  
from master.dbo.sysprocesses (nolock)  
where status like "RUNN%" order by cpu DESC  
select * from #tmpProc  
set RowCount 1  
select @QualID = spid from #tmpProc  
While @@RowCount <> 0  
  Begin  
   Print ""  
   Print "                                       ��� Comando executado pelo processo " + @QualID + " ���"  
   execute ( "dbcc inputbuffer ( " + @QualID + " )" )  
   delete from #tmpProc  
   select @QualID = spid from #tmpProc  
  End  
drop table #tmpProc  
set rowcount 0  
  
  
----------------------------
go
use master
go



CREATE PROCEDURE dbo.sp_SDS   
  @TargetDatabase sysname = NULL,     --  NULL: all dbs  
  @Level varchar(10) = 'Database',    --  or "File"  
  @UpdateUsage bit = 0,               --  default no update  
  @Unit char(2) = 'MB'                --  Megabytes, Kilobytes or Gigabytes  
AS  
  
/**************************************************************************************************  
**  
**  author: Richard Ding  
**  date:   4/8/2008  
**  usage:  list db size AND path w/o SUMmary  
**  test code: sp_SDS   --  default behavior  
**             sp_SDS 'maAster'  
**             sp_SDS NULL, NULL, 0  
**             sp_SDS NULL, 'file', 1, 'GB'  
**             sp_SDS 'Test_snapshot', 'Database', 1  
**             sp_SDS 'Test', 'File', 0, 'kb'  
**             sp_SDS 'pfaids', 'Database', 0, 'gb'  
**             sp_SDS 'tempdb', NULL, 1, 'kb'  
**     
**************************************************************************************************/  
  
SET NOCOUNT ON;  
  
IF @TargetDatabase IS NOT NULL AND DB_ID(@TargetDatabase) IS NULL  
  BEGIN  
    RAISERROR(15010, -1, -1, @TargetDatabase);  
    RETURN (-1)  
  END  
  
IF OBJECT_ID('tempdb.dbo.##Tbl_CombinedInfo', 'U') IS NOT NULL  
  DROP TABLE dbo.##Tbl_CombinedInfo;  
    
IF OBJECT_ID('tempdb.dbo.##Tbl_DbFileStats', 'U') IS NOT NULL  
  DROP TABLE dbo.##Tbl_DbFileStats;  
    
IF OBJECT_ID('tempdb.dbo.##Tbl_ValidDbs', 'U') IS NOT NULL  
  DROP TABLE dbo.##Tbl_ValidDbs;  
    
IF OBJECT_ID('tempdb.dbo.##Tbl_Logs', 'U') IS NOT NULL  
  DROP TABLE dbo.##Tbl_Logs;  
    
CREATE TABLE dbo.##Tbl_CombinedInfo (  
  DatabaseName sysname NULL,   
  [type] VARCHAR(10) NULL,   
  LogicalName sysname NULL,  
  T dec(10, 2) NULL,  
  U dec(10, 2) NULL,  
  [U(%)] dec(5, 2) NULL,  
  F dec(10, 2) NULL,  
  [F(%)] dec(5, 2) NULL,  
  PhysicalName sysname NULL );  
  
CREATE TABLE dbo.##Tbl_DbFileStats (  
  Id int identity,   
  DatabaseName sysname NULL,   
  FileId int NULL,   
  FileGroup int NULL,   
  TotalExtents bigint NULL,   
  UsedExtents bigint NULL,   
  Name sysname NULL,   
  FileName varchar(255) NULL );  
    
CREATE TABLE dbo.##Tbl_ValidDbs (  
  Id int identity,   
  Dbname sysname NULL );  
    
CREATE TABLE dbo.##Tbl_Logs (  
  DatabaseName sysname NULL,   
  LogSize dec (10, 2) NULL,   
  LogSpaceUsedPercent dec (5, 2) NULL,  
  Status int NULL );  
  
DECLARE @Ver varchar(10),   
        @DatabaseName sysname,   
        @Ident_last int,   
        @String varchar(2000),  
        @BaseString varchar(2000);  
          
SELECT @DatabaseName = '',   
       @Ident_last = 0,   
       @String = '',   
       @Ver = CASE WHEN @@VERSION LIKE '%9.0%' THEN 'SQL 2005'   
                   WHEN @@VERSION LIKE '%8.0%' THEN 'SQL 2000'   
                   WHEN @@VERSION LIKE '%10.0%' THEN 'SQL 2008'   
              END;  
                
SELECT @BaseString =   
' SELECT DB_NAME(), ' +   
CASE WHEN @Ver = 'SQL 2000' THEN 'CASE WHEN status & 0x40 = 0x40 THEN ''Log''  ELSE ''Data'' END'   
  ELSE ' CASE type WHEN 0 THEN ''Data'' WHEN 1 THEN ''Log'' WHEN 4 THEN ''Full-text'' ELSE ''reserved'' END' END +   
', name, ' +   
CASE WHEN @Ver = 'SQL 2000' THEN 'filename' ELSE 'physical_name' END +   
', size*8.0/1024.0 FROM ' +   
CASE WHEN @Ver = 'SQL 2000' THEN 'sysfiles' ELSE 'sys.database_files' END +   
' WHERE '  
+ CASE WHEN @Ver = 'SQL 2000' THEN ' HAS_DBACCESS(DB_NAME()) = 1' ELSE 'state_desc = ''ONLINE''' END + '';  
  
SELECT @String = 'INSERT INTO dbo.##Tbl_ValidDbs SELECT name FROM ' +   
                 CASE WHEN @Ver = 'SQL 2000' THEN 'master.dbo.sysdatabases'   
                      WHEN @Ver IN ('SQL 2005', 'SQL 2008') THEN 'master.sys.databases'   
                 END + ' WHERE HAS_DBACCESS(name) = 1 ORDER BY name ASC';  
EXEC (@String);  
  
INSERT INTO dbo.##Tbl_Logs EXEC ('DBCC SQLPERF (LOGSPACE) WITH NO_INFOMSGS');  
  
--  For data part  
IF @TargetDatabase IS NOT NULL  
  BEGIN  
    SELECT @DatabaseName = @TargetDatabase;  
    IF @UpdateUsage <> 0 AND DATABASEPROPERTYEX (@DatabaseName,'Status') = 'ONLINE'   
          AND DATABASEPROPERTYEX (@DatabaseName, 'Updateability') <> 'READ_ONLY'  
      BEGIN  
        SELECT @String = 'USE [' + @DatabaseName + '] DBCC UPDATEUSAGE (0)';  
        PRINT '*** ' + @String + ' *** ';  
        EXEC (@String);  
        PRINT '';  
      END  
        
    SELECT @String = 'INSERT INTO dbo.##Tbl_CombinedInfo (DatabaseName, type, LogicalName, PhysicalName, T) ' + @BaseString;   
  
    INSERT INTO dbo.##Tbl_DbFileStats (FileId, FileGroup, TotalExtents, UsedExtents, Name, FileName)  
          EXEC ('USE [' + @DatabaseName + '] DBCC SHOWFILESTATS WITH NO_INFOMSGS');  
    EXEC ('USE [' + @DatabaseName + '] ' + @String);  
          
    UPDATE dbo.##Tbl_DbFileStats SET DatabaseName = @DatabaseName;   
  END  
ELSE  
  BEGIN  
    WHILE 1 = 1  
      BEGIN  
        SELECT TOP 1 @DatabaseName = Dbname FROM dbo.##Tbl_ValidDbs WHERE Dbname > @DatabaseName ORDER BY Dbname ASC;  
        IF @@ROWCOUNT = 0  
          BREAK;  
        IF @UpdateUsage <> 0 AND DATABASEPROPERTYEX (@DatabaseName, 'Status') = 'ONLINE'   
              AND DATABASEPROPERTYEX (@DatabaseName, 'Updateability') <> 'READ_ONLY'  
          BEGIN  
            SELECT @String = 'DBCC UPDATEUSAGE (''' + @DatabaseName + ''') ';  
            PRINT '*** ' + @String + '*** ';  
            EXEC (@String);  
            PRINT '';  
          END  
      
        SELECT @Ident_last = ISNULL(MAX(Id), 0) FROM dbo.##Tbl_DbFileStats;  
  
        SELECT @String = 'INSERT INTO dbo.##Tbl_CombinedInfo (DatabaseName, type, LogicalName, PhysicalName, T) ' + @BaseString;   
  
        EXEC ('USE [' + @DatabaseName + '] ' + @String);  
        
        INSERT INTO dbo.##Tbl_DbFileStats (FileId, FileGroup, TotalExtents, UsedExtents, Name, FileName)  
          EXEC ('USE [' + @DatabaseName + '] DBCC SHOWFILESTATS WITH NO_INFOMSGS');  
  
        UPDATE dbo.##Tbl_DbFileStats SET DatabaseName = @DatabaseName WHERE Id BETWEEN @Ident_last + 1 AND @@IDENTITY;  
      END  
  END  
  
--  set used size for data files, do not change total obtained from sys.database_files as it has for log files  
UPDATE dbo.##Tbl_CombinedInfo   
SET U = s.UsedExtents*8*8/1024.0   
FROM dbo.##Tbl_CombinedInfo t JOIN dbo.##Tbl_DbFileStats s   
ON t.LogicalName = s.Name AND s.DatabaseName = t.DatabaseName;  
  
--  set used size and % values for log files:  
UPDATE dbo.##Tbl_CombinedInfo   
SET [U(%)] = LogSpaceUsedPercent,   
U = T * LogSpaceUsedPercent/100.0  
FROM dbo.##Tbl_CombinedInfo t JOIN dbo.##Tbl_Logs l   
ON l.DatabaseName = t.DatabaseName   
WHERE t.type = 'Log';  
  
UPDATE dbo.##Tbl_CombinedInfo SET F = T - U, [U(%)] = U*100.0/T;  
  
UPDATE dbo.##Tbl_CombinedInfo SET [F(%)] = F*100.0/T;  
  
IF UPPER(ISNULL(@Level, 'DATABASE')) = 'FILE'  
  BEGIN  
    IF @Unit = 'KB'  
      UPDATE dbo.##Tbl_CombinedInfo  
      SET T = T * 1024, U = U * 1024, F = F * 1024;  
        
    IF @Unit = 'GB'  
      UPDATE dbo.##Tbl_CombinedInfo  
      SET T = T / 1024, U = U / 1024, F = F / 1024;  
        
    SELECT DatabaseName AS 'Database',  
      type AS 'Type',  
      LogicalName,  
      T AS 'Total',  
      U AS 'Used',  
      [U(%)] AS 'Used (%)',  
      F AS 'Free',  
      [F(%)] AS 'Free (%)',  
      PhysicalName  
      FROM dbo.##Tbl_CombinedInfo   
      WHERE DatabaseName LIKE ISNULL(@TargetDatabase, '%')   
      ORDER BY DatabaseName ASC, type ASC;  
  
    SELECT CASE WHEN @Unit = 'GB' THEN 'GB' WHEN @Unit = 'KB' THEN 'KB' ELSE 'MB' END AS 'SUM',  
        SUM (T) AS 'TOTAL', SUM (U) AS 'USED', SUM (F) AS 'FREE' FROM dbo.##Tbl_CombinedInfo;  
  END  
  
IF UPPER(ISNULL(@Level, 'DATABASE')) = 'DATABASE'  
  BEGIN  
    DECLARE @Tbl_Final TABLE (  
      DatabaseName sysname NULL,  
      TOTAL dec (10, 2),  
      [=] char(1),  
      used dec (10, 2),  
      [used (%)] dec (5, 2),  
      [+] char(1),  
      free dec (10, 2),  
      [free (%)] dec (5, 2),  
      [==] char(2),  
      Data dec (10, 2),  
      Data_Used dec (10, 2),  
      [Data_Used (%)] dec (5, 2),  
      Data_Free dec (10, 2),  
      [Data_Free (%)] dec (5, 2),  
      [++] char(2),  
      Log dec (10, 2),  
      Log_Used dec (10, 2),  
      [Log_Used (%)] dec (5, 2),  
      Log_Free dec (10, 2),  
      [Log_Free (%)] dec (5, 2) );  
  
    INSERT INTO @Tbl_Final  
      SELECT x.DatabaseName,   
           x.Data + y.Log AS 'TOTAL',   
           '=' AS '=',   
           x.Data_Used + y.Log_Used AS 'U',  
           (x.Data_Used + y.Log_Used)*100.0 / (x.Data + y.Log)  AS 'U(%)',  
           '+' AS '+',  
           x.Data_Free + y.Log_Free AS 'F',  
           (x.Data_Free + y.Log_Free)*100.0 / (x.Data + y.Log)  AS 'F(%)',  
           '==' AS '==',  
           x.Data,   
           x.Data_Used,   
           x.Data_Used*100/x.Data AS 'D_U(%)',  
           x.Data_Free,   
           x.Data_Free*100/x.Data AS 'D_F(%)',  
           '++' AS '++',   
           y.Log,   
           y.Log_Used,   
           y.Log_Used*100/y.Log AS 'L_U(%)',  
           y.Log_Free,   
           y.Log_Free*100/y.Log AS 'L_F(%)'  
      FROM   
      ( SELECT d.DatabaseName,   
               SUM(d.T) AS 'Data',   
               SUM(d.U) AS 'Data_Used',   
               SUM(d.F) AS 'Data_Free'   
          FROM dbo.##Tbl_CombinedInfo d WHERE d.type = 'Data' GROUP BY d.DatabaseName ) AS x  
      JOIN   
      ( SELECT l.DatabaseName,   
               SUM(l.T) AS 'Log',   
               SUM(l.U) AS 'Log_Used',   
               SUM(l.F) AS 'Log_Free'   
          FROM dbo.##Tbl_CombinedInfo l WHERE l.type = 'Log' GROUP BY l.DatabaseName ) AS y  
      ON x.DatabaseName = y.DatabaseName;  
      
    IF @Unit = 'KB'  
      UPDATE @Tbl_Final SET TOTAL = TOTAL * 1024,  
      used = used * 1024,  
      free = free * 1024,  
      Data = Data * 1024,  
      Data_Used = Data_Used * 1024,  
      Data_Free = Data_Free * 1024,  
      Log = Log * 1024,  
      Log_Used = Log_Used * 1024,  
      Log_Free = Log_Free * 1024;  
        
     IF @Unit = 'GB'  
      UPDATE @Tbl_Final SET TOTAL = TOTAL / 1024,  
      used = used / 1024,  
      free = free / 1024,  
      Data = Data / 1024,  
      Data_Used = Data_Used / 1024,  
      Data_Free = Data_Free / 1024,  
      Log = Log / 1024,  
      Log_Used = Log_Used / 1024,  
      Log_Free = Log_Free / 1024;  
        
      DECLARE @GrantTotal dec(11, 2);  
      SELECT @GrantTotal = SUM(TOTAL) FROM @Tbl_Final;  
  
      SELECT   
      CONVERT(dec(10, 2), TOTAL*100.0/@GrantTotal) AS 'WEIGHT (%)',   
      DatabaseName AS 'DATABASE',  
      CONVERT(VARCHAR(12), used) + '  (' + CONVERT(VARCHAR(12), [used (%)]) + ' %)' AS 'USED  (%)',  
      [+],  
      CONVERT(VARCHAR(12), free) + '  (' + CONVERT(VARCHAR(12), [free (%)]) + ' %)' AS 'FREE  (%)',  
      [=],  
      TOTAL,   
      [=],  
      CONVERT(VARCHAR(12), Data) + '  (' + CONVERT(VARCHAR(12), Data_Used) + ',  ' +   
      CONVERT(VARCHAR(12), [Data_Used (%)]) + '%)' AS 'DATA  (used,  %)',  
      [+],  
      CONVERT(VARCHAR(12), Log) + '  (' + CONVERT(VARCHAR(12), Log_Used) + ',  ' +   
      CONVERT(VARCHAR(12), [Log_Used (%)]) + '%)' AS 'LOG  (used,  %)'  
        FROM @Tbl_Final   
        WHERE DatabaseName LIKE ISNULL(@TargetDatabase, '%')  
        ORDER BY DatabaseName ASC;  
          
    IF @TargetDatabase IS NULL  
      SELECT CASE WHEN @Unit = 'GB' THEN 'GB' WHEN @Unit = 'KB' THEN 'KB' ELSE 'MB' END AS 'SUM',   
      SUM (used) AS 'USED',   
      SUM (free) AS 'FREE',   
      SUM (TOTAL) AS 'TOTAL',   
      SUM (Data) AS 'DATA',   
      SUM (Log) AS 'LOG'   
      FROM @Tbl_Final;  
  END  
    
RETURN (0)  
  --------------------
  go
use master
go


CREATE PROCEDURE dbo.spu_get_db_files_near_maxsize (@nearMaxSizePct DECIMAL (5,1) = 10.0)  
AS  
BEGIN  
SET NOCOUNT ON  
  
CREATE TABLE ##ALL_DB_Files (  
dbname SYSNAME,  
fileid smallint,  
groupid smallint,  
[size] INT NOT NULL,  
[maxsize] INT NOT NULL,  
growth INT NOT NULL,  
status INT,  
perf INT,  
[name] SYSNAME NOT NULL,  
[filename] NVARCHAR(260) NOT NULL)  
  
-- loop over all databases and collect the information from sysfiles  
-- to the ALL_DB_Files tables using the sp_MsForEachDB system procedure  
EXEC sp_MsForEachDB  
@command1='use [$];Insert into ##ALL_DB_Files select db_name(), * from sysfiles',  
@replacechar = '$'  
  
-- output the results  
SELECT   
[dbname] AS DatabaseName,  
[name] AS dbFileLogicalName,  
[filename] AS dbFilePhysicalFilePath,  
ROUND(size * CONVERT(FLOAT,8) / 1024,0) AS ActualSizeMB,  
ROUND(maxsize * CONVERT(FLOAT,8) / 1024,0) AS MaxRestrictedSizeMB,  
ROUND(maxsize * CONVERT(FLOAT,8) / 1024,0) - ROUND(size * CONVERT(FLOAT,8) / 1024,0) AS SpaceLeftMB  
FROM ##ALL_DB_Files  
WHERE maxsize > -1 AND -- skip db files that have no max size   
([maxsize] - [size]) * 1.0 < 0.01 * @nearMaxSizePct * [maxsize] -- find db files within percentage  
ORDER BY 6  
  
DROP TABLE ##ALL_DB_Files  
  
SET NOCOUNT OFF  
END  

-------------------

go
use master
go



CREATE PROC sp_generate_inserts  
(  
 @table_name varchar(776),    -- The table/view for which the INSERT statements will be generated using the existing data  
 @target_table varchar(776) = NULL,  -- Use this parameter to specify a different table name into which the data will be inserted  
 @include_column_list bit = 1,  -- Use this parameter to include/ommit column list in the generated INSERT statement  
 @from varchar(800) = NULL,   -- Use this parameter to filter the rows based on a filter condition (using WHERE)  
 @include_timestamp bit = 0,   -- Specify 1 for this parameter, if you want to include the TIMESTAMP/ROWVERSION column's data in the INSERT statement  
 @debug_mode bit = 0,   -- If @debug_mode is set to 1, the SQL statements constructed by this procedure will be printed for later examination  
 @owner varchar(64) = NULL,  -- Use this parameter if you are not the owner of the table  
 @ommit_images bit = 0,   -- Use this parameter to generate INSERT statements by omitting the 'image' columns  
 @ommit_identity bit = 0,  -- Use this parameter to ommit the identity columns  
 @top int = NULL,   -- Use this parameter to generate INSERT statements only for the TOP n rows  
 @cols_to_include varchar(8000) = NULL, -- List of columns to be included in the INSERT statement  
 @cols_to_exclude varchar(8000) = NULL, -- List of columns to be excluded from the INSERT statement  
 @disable_constraints bit = 0,  -- When 1, disables foreign key constraints and enables them after the INSERT statements  
 @ommit_computed_cols bit = 0  -- When 1, computed columns will not be included in the INSERT statement  
   
)  
AS  
BEGIN  
  
/***********************************************************************************************************  
Procedure: sp_generate_inserts  (Build 22)   
  (Copyright � 2002 Narayana Vyas Kondreddi. All rights reserved.)  
                                            
Purpose: To generate INSERT statements from existing data.   
  These INSERTS can be executed to regenerate the data at some other location.  
  This procedure is also useful to create a database setup, where in you can   
  script your data along with your table definitions.  
  
Written by: Narayana Vyas Kondreddi  
         http://vyaskn.tripod.com  
  
Acknowledgements:  
  Divya Kalra -- For beta testing  
  Mark Charsley -- For reporting a problem with scripting uniqueidentifier columns with NULL values  
  Artur Zeygman -- For helping me simplify a bit of code for handling non-dbo owned tables  
  Joris Laperre   -- For reporting a regression bug in handling text/ntext columns  
  
Tested on:  SQL Server 7.0 and SQL Server 2000  
  
Date created: January 17th 2001 21:52 GMT  
  
Date modified: May 1st 2002 19:50 GMT  
  
Email:   vyaskn@hotmail.com  
  
NOTE:  This procedure may not work with tables with too many columns.  
  Results can be unpredictable with huge text columns or SQL Server 2000's sql_variant data types  
  Whenever possible, Use @include_column_list parameter to ommit column list in the INSERT statement, for better results  
  IMPORTANT: This procedure is not tested with internation data (Extended characters or Unicode). If needed  
  you might want to convert the datatypes of character variables in this procedure to their respective unicode counterparts  
  like nchar and nvarchar  
    
  
Example 1: To generate INSERT statements for table 'titles':  
    
  EXEC sp_generate_inserts 'titles'  
  
Example 2:  To ommit the column list in the INSERT statement: (Column list is included by default)  
  IMPORTANT: If you have too many columns, you are advised to ommit column list, as shown below,  
  to avoid erroneous results  
    
  EXEC sp_generate_inserts 'titles', @include_column_list = 0  
  
Example 3: To generate INSERT statements for 'titlesCopy' table from 'titles' table:  
  
  EXEC sp_generate_inserts 'titles', 'titlesCopy'  
  
Example 4: To generate INSERT statements for 'titles' table for only those titles   
  which contain the word 'Computer' in them:  
  NOTE: Do not complicate the FROM or WHERE clause here. It's assumed that you are good with T-SQL if you are using this parameter  
  
  EXEC sp_generate_inserts 'titles', @from = "from titles where title like '%Computer%'"  
  
Example 5:  To specify that you want to include TIMESTAMP column's data as well in the INSERT statement:  
  (By default TIMESTAMP column's data is not scripted)  
  
  EXEC sp_generate_inserts 'titles', @include_timestamp = 1  
  
Example 6: To print the debug information:  
    
  EXEC sp_generate_inserts 'titles', @debug_mode = 1  
  
Example 7:  If you are not the owner of the table, use @owner parameter to specify the owner name  
  To use this option, you must have SELECT permissions on that table  
  
  EXEC sp_generate_inserts Nickstable, @owner = 'Nick'  
  
Example 8:  To generate INSERT statements for the rest of the columns excluding images  
  When using this otion, DO NOT set @include_column_list parameter to 0.  
  
  EXEC sp_generate_inserts imgtable, @ommit_images = 1  
  
Example 9:  To generate INSERT statements excluding (ommiting) IDENTITY columns:  
  (By default IDENTITY columns are included in the INSERT statement)  
  
  EXEC sp_generate_inserts mytable, @ommit_identity = 1  
  
Example 10:  To generate INSERT statements for the TOP 10 rows in the table:  
    
  EXEC sp_generate_inserts mytable, @top = 10  
  
Example 11:  To generate INSERT statements with only those columns you want:  
    
  EXEC sp_generate_inserts titles, @cols_to_include = "'title','title_id','au_id'"  
  
Example 12:  To generate INSERT statements by omitting certain columns:  
    
  EXEC sp_generate_inserts titles, @cols_to_exclude = "'title','title_id','au_id'"  
  
Example 13: To avoid checking the foreign key constraints while loading data with INSERT statements:  
    
  EXEC sp_generate_inserts titles, @disable_constraints = 1  
  
Example 14:  To exclude computed columns from the INSERT statement:  
  EXEC sp_generate_inserts MyTable, @ommit_computed_cols = 1  
***********************************************************************************************************/  
  
SET NOCOUNT ON  
  
--Making sure user only uses either @cols_to_include or @cols_to_exclude  
IF ((@cols_to_include IS NOT NULL) AND (@cols_to_exclude IS NOT NULL))  
 BEGIN  
  RAISERROR('Use either @cols_to_include or @cols_to_exclude. Do not use both the parameters at once',16,1)  
  RETURN -1 --Failure. Reason: Both @cols_to_include and @cols_to_exclude parameters are specified  
 END  
  
--Making sure the @cols_to_include and @cols_to_exclude parameters are receiving values in proper format  
IF ((@cols_to_include IS NOT NULL) AND (PATINDEX('''%''',@cols_to_include) = 0))  
 BEGIN  
  RAISERROR('Invalid use of @cols_to_include property',16,1)  
  PRINT 'Specify column names surrounded by single quotes and separated by commas'  
  PRINT 'Eg: EXEC sp_generate_inserts titles, @cols_to_include = "''title_id'',''title''"'  
  RETURN -1 --Failure. Reason: Invalid use of @cols_to_include property  
 END  
  
IF ((@cols_to_exclude IS NOT NULL) AND (PATINDEX('''%''',@cols_to_exclude) = 0))  
 BEGIN  
  RAISERROR('Invalid use of @cols_to_exclude property',16,1)  
  PRINT 'Specify column names surrounded by single quotes and separated by commas'  
  PRINT 'Eg: EXEC sp_generate_inserts titles, @cols_to_exclude = "''title_id'',''title''"'  
  RETURN -1 --Failure. Reason: Invalid use of @cols_to_exclude property  
 END  
  
  
--Checking to see if the database name is specified along wih the table name  
--Your database context should be local to the table for which you want to generate INSERT statements  
--specifying the database name is not allowed  
IF (PARSENAME(@table_name,3)) IS NOT NULL  
 BEGIN  
  RAISERROR('Do not specify the database name. Be in the required database and just specify the table name.',16,1)  
  RETURN -1 --Failure. Reason: Database name is specified along with the table name, which is not allowed  
 END  
  
--Checking for the existence of 'user table' or 'view'  
--This procedure is not written to work on system tables  
--To script the data in system tables, just create a view on the system tables and script the view instead  
  
IF @owner IS NULL  
 BEGIN  
  IF ((OBJECT_ID(@table_name,'U') IS NULL) AND (OBJECT_ID(@table_name,'V') IS NULL))   
   BEGIN  
    RAISERROR('User table or view not found.',16,1)  
    PRINT 'You may see this error, if you are not the owner of this table or view. In that case use @owner parameter to specify the owner name.'  
    PRINT 'Make sure you have SELECT permission on that table or view.'  
    RETURN -1 --Failure. Reason: There is no user table or view with this name  
   END  
 END  
ELSE  
 BEGIN  
  IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @table_name AND (TABLE_TYPE = 'BASE TABLE' OR TABLE_TYPE = 'VIEW') AND TABLE_SCHEMA = @owner)  
   BEGIN  
    RAISERROR('User table or view not found.',16,1)  
    PRINT 'You may see this error, if you are not the owner of this table. In that case use @owner parameter to specify the owner name.'  
    PRINT 'Make sure you have SELECT permission on that table or view.'  
    RETURN -1 --Failure. Reason: There is no user table or view with this name    
   END  
 END  
  
--Variable declarations  
DECLARE  @Column_ID int,     
  @Column_List varchar(8000),   
  @Column_Name varchar(128),   
  @Start_Insert varchar(786),   
  @Data_Type varchar(128),   
  @Actual_Values varchar(8000), --This is the string that will be finally executed to generate INSERT statements  
  @IDN varchar(128)  --Will contain the IDENTITY column's name in the table  
  
--Variable Initialization  
SET @IDN = ''  
SET @Column_ID = 0  
SET @Column_Name = ''  
SET @Column_List = ''  
SET @Actual_Values = ''  
  
IF @owner IS NULL   
 BEGIN  
  SET @Start_Insert = 'INSERT INTO ' + '[' + RTRIM(COALESCE(@target_table,@table_name)) + ']'   
 END  
ELSE  
 BEGIN  
  SET @Start_Insert = 'INSERT ' + '[' + LTRIM(RTRIM(@owner)) + '].' + '[' + RTRIM(COALESCE(@target_table,@table_name)) + ']'     
 END  
  
  
--To get the first column's ID  
  
SELECT @Column_ID = MIN(ORDINAL_POSITION)    
FROM INFORMATION_SCHEMA.COLUMNS (NOLOCK)   
WHERE  TABLE_NAME = @table_name AND  
(@owner IS NULL OR TABLE_SCHEMA = @owner)  
  
   
  
--Loop through all the columns of the table, to get the column names and their data types  
WHILE @Column_ID IS NOT NULL  
 BEGIN  
  SELECT  @Column_Name = QUOTENAME(COLUMN_NAME),   
  @Data_Type = DATA_TYPE   
  FROM  INFORMATION_SCHEMA.COLUMNS (NOLOCK)   
  WHERE  ORDINAL_POSITION = @Column_ID AND   
  TABLE_NAME = @table_name AND  
  (@owner IS NULL OR TABLE_SCHEMA = @owner)  
  
   
  
  IF @cols_to_include IS NOT NULL --Selecting only user specified columns  
  BEGIN  
   IF CHARINDEX( '''' + SUBSTRING(@Column_Name,2,LEN(@Column_Name)-2) + '''',@cols_to_include) = 0   
   BEGIN  
    GOTO SKIP_LOOP  
   END  
  END  
  
  IF @cols_to_exclude IS NOT NULL --Selecting only user specified columns  
  BEGIN  
   IF CHARINDEX( '''' + SUBSTRING(@Column_Name,2,LEN(@Column_Name)-2) + '''',@cols_to_exclude) <> 0   
   BEGIN  
    GOTO SKIP_LOOP  
   END  
  END  
  
  --Making sure to output SET IDENTITY_INSERT ON/OFF in case the table has an IDENTITY column  
  IF (SELECT COLUMNPROPERTY( OBJECT_ID(QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + @table_name),SUBSTRING(@Column_Name,2,LEN(@Column_Name) - 2),'IsIdentity')) = 1   
  BEGIN  
   IF @ommit_identity = 0 --Determing whether to include or exclude the IDENTITY column  
    SET @IDN = @Column_Name  
   ELSE  
    GOTO SKIP_LOOP     
  END  
    
  --Making sure whether to output computed columns or not  
  IF @ommit_computed_cols = 1  
  BEGIN  
   IF (SELECT COLUMNPROPERTY( OBJECT_ID(QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + @table_name),SUBSTRING(@Column_Name,2,LEN(@Column_Name) - 2),'IsComputed')) = 1   
   BEGIN  
    GOTO SKIP_LOOP       
   END  
  END  
    
  --Tables with columns of IMAGE data type are not supported for obvious reasons  
  IF(@Data_Type in ('image'))  
   BEGIN  
    IF (@ommit_images = 0)  
     BEGIN  
      RAISERROR('Tables with image columns are not supported.',16,1)  
      PRINT 'Use @ommit_images = 1 parameter to generate INSERTs for the rest of the columns.'  
      PRINT 'DO NOT ommit Column List in the INSERT statements. If you ommit column list using @include_column_list=0, the generated INSERTs will fail.'  
      RETURN -1 --Failure. Reason: There is a column with image data type  
     END  
    ELSE  
     BEGIN  
     GOTO SKIP_LOOP  
     END  
   END  
  
  --Determining the data type of the column and depending on the data type, the VALUES part of  
  --the INSERT statement is generated. Care is taken to handle columns with NULL values. Also  
  --making sure, not to lose any data from flot, real, money, smallmomey, datetime columns  
  SET @Actual_Values = @Actual_Values  +  
  CASE   
   WHEN @Data_Type IN ('char','varchar','nchar','nvarchar')   
    THEN   
     'COALESCE('''''''' + REPLACE(RTRIM(' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')'  
   WHEN @Data_Type IN ('datetime','smalldatetime')   
    THEN   
     'COALESCE('''''''' + RTRIM(CONVERT(char,' + @Column_Name + ',109))+'''''''',''NULL'')'  
   WHEN @Data_Type IN ('uniqueidentifier')   
    THEN    
     'COALESCE('''''''' + REPLACE(CONVERT(char(255),RTRIM(' + @Column_Name + ')),'''''''','''''''''''')+'''''''',''NULL'')'  
   WHEN @Data_Type IN ('text','ntext')   
    THEN    
     'COALESCE('''''''' + REPLACE(CONVERT(char(8000),' + @Column_Name + '),'''''''','''''''''''')+'''''''',''NULL'')'       
   WHEN @Data_Type IN ('binary','varbinary')   
    THEN    
     'COALESCE(RTRIM(CONVERT(char,' + 'CONVERT(int,' + @Column_Name + '))),''NULL'')'    
   WHEN @Data_Type IN ('timestamp','rowversion')   
    THEN    
     CASE   
      WHEN @include_timestamp = 0   
       THEN   
        '''DEFAULT'''   
       ELSE   
        'COALESCE(RTRIM(CONVERT(char,' + 'CONVERT(int,' + @Column_Name + '))),''NULL'')'    
     END  
   WHEN @Data_Type IN ('float','real','money','smallmoney')  
    THEN  
     'COALESCE(LTRIM(RTRIM(' + 'CONVERT(char, ' +  @Column_Name  + ',2)' + ')),''NULL'')'   
   ELSE   
    'COALESCE(LTRIM(RTRIM(' + 'CONVERT(char, ' +  @Column_Name  + ')' + ')),''NULL'')'   
  END   + '+' +  ''',''' + ' + '  
    
  --Generating the column list for the INSERT statement  
  SET @Column_List = @Column_List +  @Column_Name + ','   
  
  SKIP_LOOP: --The label used in GOTO  
  
  SELECT  @Column_ID = MIN(ORDINAL_POSITION)   
  FROM  INFORMATION_SCHEMA.COLUMNS (NOLOCK)   
  WHERE  TABLE_NAME = @table_name AND   
  ORDINAL_POSITION > @Column_ID AND  
  (@owner IS NULL OR TABLE_SCHEMA = @owner)  
  
  
 --Loop ends here!  
 END  
  
--To get rid of the extra characters that got concatenated during the last run through the loop  
SET @Column_List = LEFT(@Column_List,len(@Column_List) - 1)  
SET @Actual_Values = LEFT(@Actual_Values,len(@Actual_Values) - 6)  
  
IF LTRIM(@Column_List) = ''   
 BEGIN  
  RAISERROR('No columns to select. There should at least be one column to generate the output',16,1)  
  RETURN -1 --Failure. Reason: Looks like all the columns are ommitted using the @cols_to_exclude parameter  
 END  
  
--Forming the final string that will be executed, to output the INSERT statements  
IF (@include_column_list <> 0)  
 BEGIN  
  SET @Actual_Values =   
   'SELECT ' +    
   CASE WHEN @top IS NULL OR @top < 0 THEN '' ELSE ' TOP ' + LTRIM(STR(@top)) + ' ' END +   
   '''' + RTRIM(@Start_Insert) +   
   ' ''+' + '''(' + RTRIM(@Column_List) +  '''+' + ''')''' +   
   ' +''VALUES(''+ ' +  @Actual_Values  + '+'')''' + ' ' +   
   COALESCE(@from,' FROM ' + CASE WHEN @owner IS NULL THEN '' ELSE '[' + LTRIM(RTRIM(@owner)) + '].' END + '[' + rtrim(@table_name) + ']' + '(NOLOCK)')  
 END  
ELSE IF (@include_column_list = 0)  
 BEGIN  
  SET @Actual_Values =   
   'SELECT ' +   
   CASE WHEN @top IS NULL OR @top < 0 THEN '' ELSE ' TOP ' + LTRIM(STR(@top)) + ' ' END +   
   '''' + RTRIM(@Start_Insert) +   
   ' '' +''VALUES(''+ ' +  @Actual_Values + '+'')''' + ' ' +   
   COALESCE(@from,' FROM ' + CASE WHEN @owner IS NULL THEN '' ELSE '[' + LTRIM(RTRIM(@owner)) + '].' END + '[' + rtrim(@table_name) + ']' + '(NOLOCK)')  
 END   
  
--Determining whether to ouput any debug information  
IF @debug_mode =1  
 BEGIN  
  PRINT '/*****START OF DEBUG INFORMATION*****'  
  PRINT 'Beginning of the INSERT statement:'  
  PRINT @Start_Insert  
  PRINT ''  
  PRINT 'The column list:'  
  PRINT @Column_List  
  PRINT ''  
  PRINT 'The SELECT statement executed to generate the INSERTs'  
  PRINT @Actual_Values  
  PRINT ''  
  PRINT '*****END OF DEBUG INFORMATION*****/'  
  PRINT ''  
 END  
    
PRINT '--INSERTs generated by ''sp_generate_inserts'' stored procedure written by Vyas'  
PRINT '--Build number: 22'  
PRINT '--Problems/Suggestions? Contact Vyas @ vyaskn@hotmail.com'  
PRINT '--http://vyaskn.tripod.com'  
PRINT ''  
PRINT 'SET NOCOUNT ON'  
PRINT ''  
  
  
--Determining whether to print IDENTITY_INSERT or not  
IF (@IDN <> '')  
 BEGIN  
  PRINT 'SET IDENTITY_INSERT ' + QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + QUOTENAME(@table_name) + ' ON'  
  PRINT 'GO'  
  PRINT ''  
 END  
  
  
IF @disable_constraints = 1 AND (OBJECT_ID(QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + @table_name, 'U') IS NOT NULL)  
 BEGIN  
  IF @owner IS NULL  
   BEGIN  
    SELECT  'ALTER TABLE ' + QUOTENAME(COALESCE(@target_table, @table_name)) + ' NOCHECK CONSTRAINT ALL' AS '--Code to disable constraints temporarily'  
   END  
  ELSE  
   BEGIN  
    SELECT  'ALTER TABLE ' + QUOTENAME(@owner) + '.' + QUOTENAME(COALESCE(@target_table, @table_name)) + ' NOCHECK CONSTRAINT ALL' AS '--Code to disable constraints temporarily'  
   END  
  
  PRINT 'GO'  
 END  
  
PRINT ''  
PRINT 'PRINT ''Inserting values into ' + '[' + RTRIM(COALESCE(@target_table,@table_name)) + ']' + ''''  
  
  
--All the hard work pays off here!!! You'll get your INSERT statements, when the next line executes!  
EXEC (@Actual_Values)  
  
PRINT 'PRINT ''Done'''  
PRINT ''  
  
  
IF @disable_constraints = 1 AND (OBJECT_ID(QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + @table_name, 'U') IS NOT NULL)  
 BEGIN  
  IF @owner IS NULL  
   BEGIN  
    SELECT  'ALTER TABLE ' + QUOTENAME(COALESCE(@target_table, @table_name)) + ' CHECK CONSTRAINT ALL'  AS '--Code to enable the previously disabled constraints'  
   END  
  ELSE  
   BEGIN  
    SELECT  'ALTER TABLE ' + QUOTENAME(@owner) + '.' + QUOTENAME(COALESCE(@target_table, @table_name)) + ' CHECK CONSTRAINT ALL' AS '--Code to enable the previously disabled constraints'  
   END  
  
  PRINT 'GO'  
 END  
  
PRINT ''  
IF (@IDN <> '')  
 BEGIN  
  PRINT 'SET IDENTITY_INSERT ' + QUOTENAME(COALESCE(@owner,USER_NAME())) + '.' + QUOTENAME(@table_name) + ' OFF'  
  PRINT 'GO'  
 END  
  
PRINT 'SET NOCOUNT OFF'  
  
  
SET NOCOUNT OFF  
RETURN 0 --Success. We are done!  
END  
  
  
  
  
  
  
  
  -----------------------


go
use master
go



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
--  
-- Procedure :  spu_findText  
--  
-- Description : Search every stored procedure for any references to a specified string of text.  
--  
-- Development : Microsoft SQL Server V7.0 / SQL Server 2000.  
-- Patches : SP3 - SQL v7.0 / SP1 - SQL 2000.  
--   
-- Platfrom : Windows 2000 Server.  
-- Patches : SP1.  
--  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
--   
-- History.  
--  
-- Date.  Version. Programmer. Details.  
--  
-- 30/09/2000 1.0.0.  Paul Hobbs Written.  
--  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
  
CREATE PROCEDURE dbo.sp_findText (  
  
    @text            VARCHAR(50)  
  
) AS  
  
    -- Adjust search text to find all contains.  
    SET @text = '%' + @text + '%'  
  
    --  Declare general purpose variables.  
    DECLARE @line    VARCHAR(300)  
    DECLARE @char    CHAR  
    DECLARE @lineNo  INTEGER  
    DECLARE @counter INTEGER  
  
    -- Declare cursor structure.  
    DECLARE @proc    VARCHAR(100),  
            @usage   VARCHAR(4000)  
  
    --  Declare cursor of stored procedures.  
    DECLARE codeCursor CURSOR  
    FOR  
        SELECT SUBSTRING(OBJECT_NAME(id),1, 100) AS sproc,  
               text  
        FROM   syscomments  
        WHERE  text LIKE @text  
  
    --  Open cursor and fetch first row.   
    OPEN codeCursor  
    FETCH NEXT FROM codeCursor  
        INTO @proc,@usage  
  
    --  Check if any stored procedures were found.  
    IF @@FETCH_STATUS <> 0 BEGIN   
        PRINT 'Text ''' + SUBSTRING(@text,2,LEN(@text)-2) + ''' not found in stored procedures on database ' + @@SERVERNAME + '.' + DB_NAME()  
  
        -- Close and release code cursor.  
        CLOSE codeCursor  
        DEALLOCATE codeCursor  
        RETURN  
    END  
  
    --  Display column titles.  
    PRINT 'Procedure' + CHAR(9) + 'Line' + CHAR(9) + 'Reference ' + CHAR(13) + CHAR(13)  
  
    --  Search each stored procedure within code cursor.  
    WHILE @@FETCH_STATUS = 0 BEGIN  
        SET @lineNo  = 0  
        SET @counter = 1  
  
        -- Process each line.  
        WHILE (@counter <> LEN(@usage)) BEGIN  
            SET @char = SUBSTRING(@usage,@counter,1)  
  
            -- Check for line breaks.  
            IF (@char = CHAR(13)) BEGIN  
                SET @lineNo = @lineNo + 1  
  
                -- Check if we found the specified text.  
                IF (PATINDEX(@text,@line) <> 0)   
                    PRINT @proc + CHAR(9) + STR(@lineNo) + CHAR(9) + LTRIM(@line)      
              
                SET @line = ''  
     END ELSE  
         IF (@char <> CHAR(10))  
      SET @line = @line + @char  
  
                SET @counter = @counter + 1  
             
        END  
     
        FETCH NEXT FROM codeCursor  
            INTO @proc,@usage  
    END  
  
    --  Close and release cursor.  
    CLOSE codeCursor  
    DEALLOCATE codeCursor  
  
    RETURN  
  
  
  ----------------------

go
use master
go




-- sp_CompareDB  
--   
-- The SP compares structures and data in 2 databases.  
-- 1. Compares if all tables in one database have analog (by name) in second database  
-- Tables not existing in one of databases won't be used for data comparing  
-- 2. Compares if structures for tables with the same names are the same. Shows structural  
-- differences like:  
-- authors  
-- Column Phone: in db1 - char(12), in db2 - char(14)  
-- sales  
-- Column Location not in db2  
-- Tables, having different structures, won't be used for data comparing. However if the tables  
-- contain columns of the same type and different length (like Phone in the example above) or  
-- tables have compatible data types (have the same type in syscolumns - char and nchar,   
-- varchar and nvarchar etc) they will be allowed for data comparing.  
-- 3. Data comparison itself.   
-- 3.1 Get information about unique keys in the tables. If there are unique keys then one of them  
-- (PK is a highest priority candidate for this role) will be used to specify rows with  
-- different data.  
-- 3.2 Get information about all data columns in the table and form predicates that will be   
-- used to compare data.  
-- 3.3 Compare data with the criteria:  
-- a. if some unique keys from the table from first database do not exist in second db (only  
-- for tables with a unique key)  
-- b. if some unique keys from the table from second database do not exist in first db (only  
-- for tables with a unique key)  
-- c. if there are rows with the same values of unique keys and different data in other  
-- columns (only for tables with a unique key)  
-- d. if there are rows in the table from first database that don't have a twin in the   
-- table from second db  
-- e. if there are rows in the table from second database that don't have a twin in the   
-- table from first db  
--------------------------------------------------------------------------------------------  
-- Parameters:  
-- 1. @db1 - name of first database to compare  
-- 2. @db2 - name of second database to compare  
-- 3. @TabList - list of tables to compare. if empty - all tables in the databases should be  
-- compared  
-- 4. @NumbToShow - number of rows with differences to show. Default - 10.  
-- 5. @OnlyStructure - flag, if set to 1, allows to avoid data comparing. Only structures should  
-- be compared. Default - 0  
-- 6. @NoTimestamp - flag, if set to 1, allows to avoid comparing of columns of timestamp  
-- data type. Default - 0  
-- 7. @VerboseLevel - if set to 1 allows to print querues used for data comparison  
--------------------------------------------------------------------------------------------  
-- Created by Viktor Gorodnichenko (c)  
-- Created on: July 5, 2001  
--------------------------------------------------------------------------------------------  
CREATE PROC sp_CompareDB  
@db1 varchar(128),  
@db2 varchar(128),  
@OnlyStructure bit = 0,  
@TabList varchar(8000) = '',  
@NumbToShow int = 10,  
@NoTimestamp bit = 0,  
@VerboseLevel tinyint = 0  
AS  
if @OnlyStructure <> 0  
set @OnlyStructure = 1  
if @NoTimestamp <> 0  
set @NoTimestamp = 1  
if @VerboseLevel <> 0  
set @VerboseLevel = 1  
  
SET NOCOUNT ON  
SET ANSI_WARNINGS ON  
SET ANSI_NULLS ON  
declare @sqlStr varchar(8000)  
set nocount on  
-- Checking if there are specified databases  
declare @SrvName sysname  
declare @DBName sysname  
set @db1 = RTRIM(LTRIM(@db1))  
set @db2 = RTRIM(LTRIM(@db2))  
set @SrvName = @@SERVERNAME  
if CHARINDEX('.',@db1) > 0  
begin  
set @SrvName = LEFT(@db1,CHARINDEX('.',@db1)-1)  
if not exists (select * from master.dbo.sysservers where srvname = @SrvName)  
begin  
print 'There is no linked server named '+@SrvName+'. End of work.'  
return   
end  
set @DBName = RIGHT(@db1,LEN(@db1)-CHARINDEX('.',@db1))  
end  
else  
set @DBName = @db1  
exec ('declare @Name sysname select @Name=name from ['+@SrvName+'].master.dbo.sysdatabases where name = '''+@DBName+'''')  
if @@rowcount = 0  
begin  
print 'There is no database named '+@db1+'. End of work.'  
return   end  
set @SrvName = @@SERVERNAME  
if CHARINDEX('.',@db2) > 0  
begin  
set @SrvName = LEFT(@db2,CHARINDEX('.',@db2)-1)  
if not exists (select * from master.dbo.sysservers where srvname = @SrvName)  
begin  
print 'There is no linked server named '+@SrvName+'. End of work.'  
return   
end  
set @DBName = RIGHT(@db2,LEN(@db2)-CHARINDEX('.',@db2))  
end  
else  
set @DBName = @db2  
exec ('declare @Name sysname select @Name=name from ['+@SrvName+'].master.dbo.sysdatabases where name = '''+@DBName+'''')  
if @@rowcount = 0  
begin  
print 'There is no database named '+@db2+'. End of work.'  
return   
end  
  
print Replicate('-',LEN(@db1)+LEN(@db2)+25)  
print 'Comparing databases '+@db1+' and '+@db2  
print Replicate('-',LEN(@db1)+LEN(@db2)+25)  
print 'Options specified:'  
print ' Compare only structures: '+CASE WHEN @OnlyStructure = 0 THEN 'No' ELSE 'Yes' END  
print ' List of tables to compare: '+CASE WHEN LEN(@TabList) = 0 THEN ' All tables' ELSE @TabList END  
print ' Max number of different rows in each table to show: '+LTRIM(STR(@NumbToShow))  
print ' Compare timestamp columns: '+CASE WHEN @NoTimestamp = 0 THEN 'No' ELSE 'Yes' END  
print ' Verbose level: '+CASE WHEN @VerboseLevel = 0 THEN 'Low' ELSE 'High' END  
  
-----------------------------------------------------------------------------------------  
-- Comparing structures  
-----------------------------------------------------------------------------------------  
print CHAR(10)+Replicate('-',36)  
print 'Comparing structure of the databases'  
print Replicate('-',36)  
if exists (select * from tempdb.dbo.sysobjects where name like '#TabToCheck%')  
drop table #TabToCheck  
create table #TabToCheck (name sysname)  
declare @NextCommaPos int  
if len(@TabList) > 0   
begin  
while 1=1  
begin  
set @NextCommaPos = CHARINDEX(',',@TabList)  
if @NextCommaPos = 0  
begin  
set @sqlStr = 'insert into #TabToCheck values('''+@TabList+''')'  
exec (@sqlStr)  
break  
end  
set @sqlStr = 'insert into #TabToCheck values('''+LEFT(@TabList,@NextCommaPos-1)+''')'  
exec (@sqlStr)  
set @TabList = RIGHT(@TabList,LEN(@TabList)-@NextCommaPos)  
end  
end  
else -- then will check all tables  
begin  
exec ('insert into #TabToCheck select name from '+@db1+'.dbo.sysobjects where type = ''U''')  
exec ('insert into #TabToCheck select name from '+@db2+'.dbo.sysobjects where type = ''U''')  
end  
-- First check if at least one table specified in @TabList exists in db1  
exec ('declare @Name sysname select @Name=name from '+@db1+'.dbo.sysobjects where name in (select * from #TabToCheck)')  
if @@rowcount = 0  
begin  
print 'No tables in '+@db1+' to check. End of work.'  
return  
end  
-- Check if tables existing in db1 are in db2 (all tables or specified in @TabList)  
if exists (select * from tempdb.dbo.sysobjects where name like '#TabNotInDB2%')  
drop table #TabNotInDB2  
create table #TabNotInDB2 (name sysname)  
insert into #TabNotInDB2   
exec ('select name from '+@db1+'.dbo.sysobjects d1o '+  
'where name in (select * from #TabToCheck) and '+  
' d1o.type = ''U'' and not exists '+  
'(select * from '+@db2+'.dbo.sysobjects d2o'+  
' where d2o.type = ''U'' and d2o.name = d1o.name)')  
if @@rowcount > 0  
begin  
print CHAR(10)+'The table(s) exist in '+@db1+', but do not exist in '+@db2+':'  
select * from #TabNotInDB2   
end  
delete from #TabToCheck where name in (select * from #TabNotInDB2)  
drop table #TabNotInDB2  
  
if exists (select * from tempdb.dbo.sysobjects where name like '#TabNotInDB1%')  
drop table #TabNotInDB1  
create table #TabNotInDB1 (name sysname)  
insert into #TabNotInDB1   
exec ('select name from '+@db2+'.dbo.sysobjects d1o '+  
'where name in (select * from #TabToCheck) and '+  
' d1o.type = ''U'' and not exists '+  
'(select * from '+@db1+'.dbo.sysobjects d2o'+  
' where d2o.type = ''U'' and d2o.name = d1o.name)')  
if @@rowcount > 0  
begin  
print CHAR(10)+'The table(s) exist in '+@db2+', but do not exist in '+@db1+':'  
select * from #TabNotInDB1   
end  
delete from #TabToCheck where name in (select * from #TabNotInDB1)  
drop table #TabNotInDB1  
-- Comparing structures of tables existing in both dbs  
print CHAR(10)+'Checking if there are tables existing in both databases having structural differences ...'+CHAR(10)  
if exists (select * from tempdb.dbo.sysobjects where name like '#DiffStructure%')  
drop table #DiffStructure  
create table #DiffStructure (name sysname)  
set @sqlStr='  
declare @TName1 sysname, @TName2 sysname, @CName1 sysname, @CName2 sysname,  
@TypeName1 sysname, @TypeName2 sysname,  
@CLen1 smallint, @CLen2 smallint, @Type1 sysname, @Type2 sysname, @PrevTName sysname  
declare @DiffStructure bit  
declare Diff cursor fast_forward for  
select d1o.name, d2o.name, d1c.name, d2c.name, d1t.name, d2t.name,  
d1c.length, d2c.length, d1c.type, d2c.type  
from ('+@db1+'.dbo.sysobjects d1o   
JOIN '+@db2+'.dbo.sysobjects d2o2 ON d1o.name = d2o2.name and d1o.type = ''U'' --only tables in both dbs  
and d1o.name in (select * from #TabToCheck)  
JOIN '+@db1+'.dbo.syscolumns d1c ON d1o.id = d1c.id  
JOIN '+@db1+'.dbo.systypes d1t ON d1c.xusertype = d1t.xusertype)  
FULL JOIN ('+@db2+'.dbo.sysobjects d2o   
JOIN '+@db1+'.dbo.sysobjects d1o2 ON d1o2.name = d2o.name and d2o.type = ''U'' --only tables in both dbs  
and d2o.name in (select * from #TabToCheck)  
JOIN '+@db2+'.dbo.syscolumns d2c ON d2c.id = d2o.id  
JOIN '+@db2+'.dbo.systypes d2t ON d2c.xusertype = d2t.xusertype)  
ON d1o.name = d2o.name and d1c.name = d2c.name  
WHERE (not exists   
(select * from '+@db2+'.dbo.sysobjects d2o2  
JOIN '+@db2+'.dbo.syscolumns d2c2 ON d2o2.id = d2c2.id  
JOIN '+@db2+'.dbo.systypes d2t2 ON d2c2.xusertype = d2t2.xusertype  
where d2o2.type = ''U''  
and d2o2.name = d1o.name   
and d2c2.name = d1c.name   
and d2t2.name = d1t.name  
and d2c2.length = d1c.length)  
OR not exists   
(select * from '+@db1+'.dbo.sysobjects d1o2  
JOIN '+@db1+'.dbo.syscolumns d1c2 ON d1o2.id = d1c2.id  
JOIN '+@db1+'.dbo.systypes d1t2 ON d1c2.xusertype = d1t2.xusertype  
where d1o2.type = ''U''  
and d1o2.name = d2o.name   
and d1c2.name = d2c.name   
and d1t2.name = d2t.name  
and d1c2.length = d2c.length))  
order by coalesce(d1o.name,d2o.name), d1c.name  
open Diff  
fetch next from Diff into @TName1, @TName2, @CName1, @CName2, @TypeName1, @TypeName2,  
@CLen1, @CLen2, @Type1, @Type2  
set @PrevTName = ''''  
set @DiffStructure = 0  
while @@fetch_status = 0  
begin  
if Coalesce(@TName1,@TName2) <> @PrevTName  
begin  
if @PrevTName <> '''' and @DiffStructure = 1  
begin  
insert into #DiffStructure values (@PrevTName)  
set @DiffStructure = 0  
end  
set @PrevTName = Coalesce(@TName1,@TName2)  
print @PrevTName  
end  
if @CName2 is null  
print '' Colimn ''+RTRIM(@CName1)+'' not in '+@db2+'''  
else  
if @CName1 is null  
print '' Colimn ''+RTRIM(@CName2)+'' not in '+@db1+'''  
else  
if @TypeName1 <> @TypeName2  
print '' Colimn ''+RTRIM(@CName1)+'': in '+@db1+' - ''+RTRIM(@TypeName1)+'', in '+@db2+' - ''+RTRIM(@TypeName2)  
else --the columns are not null(are in both dbs) and types are equal,then length are diff  
print '' Colimn ''+RTRIM(@CName1)+'': in '+@db1+' - ''+RTRIM(@TypeName1)+''(''+  
LTRIM(STR(CASE when @TypeName1=''nChar'' or @TypeName1 = ''nVarChar'' then @CLen1/2 else @CLen1 end))+  
''), in '+@db2+' - ''+RTRIM(@TypeName2)+''(''+  
LTRIM(STR(CASE when @TypeName1=''nChar'' or @TypeName1 = ''nVarChar'' then @CLen2/2 else @CLen2 end))+'')''  
if @Type1 = @Type2  
set @DiffStructure=@DiffStructure -- Do nothing. Cannot invert predicate  
else  
set @DiffStructure = 1  
fetch next from Diff into @TName1, @TName2, @CName1, @CName2, @TypeName1, @TypeName2,  
@CLen1, @CLen2, @Type1, @Type2  
end  
deallocate Diff  
if @DiffStructure = 1  
insert into #DiffStructure values (@PrevTName)  
'  
exec (@sqlStr)  
if (select count(*) from #DiffStructure) > 0  
begin  
print CHAR(10)+'The table(s) have the same name and different structure in the databases:'  
select distinct * from #DiffStructure   
delete from #TabToCheck where name in (select * from #DiffStructure)  
end  
else  
print CHAR(10)+'There are no tables with the same name and structural differences in the databases'+CHAR(10)+CHAR(10)  
if @OnlyStructure = 1  
begin  
print 'The option ''Only compare structures'' was specified. End of work.'  
return  
end  
exec ('declare @Name sysname select @Name=d1o.name  
from '+@db1+'.dbo.sysobjects d1o, '+@db2+'.dbo.sysobjects d2o   
where d1o.name = d2o.name and d1o.type = ''U'' and d2o.type = ''U''  
and d1o.name not in (''dtproperties'')   
and d1o.name in (select * from #TabToCheck)')  
if @@rowcount = 0  
begin  
print 'There are no tables with the same name and structure in the databases to compare. End of work.'  
return  
end  
  
  
-----------------------------------------------------------------------------------------  
-- Comparing data   
-----------------------------------------------------------------------------------------  
-- ##CompareStr - will be used to pass comparing strings into dynamic script  
-- to execute the string  
if exists (select * from tempdb.dbo.sysobjects where name like '##CompareStr%')  
drop table ##CompareStr  
create table ##CompareStr (Ind int, CompareStr varchar(8000))  
  
if exists (select * from tempdb.dbo.sysobjects where name like '#DiffTables%')  
drop table #DiffTables  
create table #DiffTables (Name sysname)  
if exists (select * from tempdb.dbo.sysobjects where name like '#IdenticalTables%')  
drop table #IdenticalTables  
create table #IdenticalTables (Name sysname)  
if exists (select * from tempdb.dbo.sysobjects where name like '#EmptyTables%')  
drop table #EmptyTables  
create table #EmptyTables (Name sysname)  
if exists (select * from tempdb.dbo.sysobjects where name like '#NoPKTables%')  
drop table #NoPKTables  
create table #NoPKTables (Name sysname)  
  
if exists (select * from tempdb.dbo.sysobjects where name like '#IndList1%')  
truncate table #IndList1  
else   
create table #IndList1 (IndId int, IndStatus int,  
KeyAndStr varchar(7000), KeyCommaStr varchar(1000))  
if exists (select * from tempdb.dbo.sysobjects where name like '#IndList2%')  
truncate table #IndList2  
else  
create table #IndList2 (IndId smallint, IndStatus int,  
KeyAndStr varchar(7000), KeyCommaStr varchar(1000))  
  
print Replicate('-',51)  
print 'Comparing data in tables with indentical structure:'  
print Replicate('-',51)  
--------------------------------------------------------------------------------------------  
-- Cursor for all tables in dbs (or for all specified tables if parameter @TabList is passed)  
--------------------------------------------------------------------------------------------  
declare @SqlStrGetListOfKeys1 varchar(8000)  
declare @SqlStrGetListOfKeys2 varchar(8000)  
declare @SqlStrGetListOfColumns varchar(8000)  
declare @SqlStrCompareUKeyTables varchar(8000)  
declare @SqlStrCompareNonUKeyTables varchar(8000)  
set @SqlStrGetListOfKeys1 = '  
declare @sqlStr varchar(8000)  
declare @ExecSqlStr varchar(8000)  
declare @PrintSqlStr varchar(8000)  
declare @Tab varchar(128)  
declare @d1User varchar(128)  
declare @d2User varchar(128)  
declare @KeyAndStr varchar(8000)   
declare @KeyCommaStr varchar(8000)   
declare @AndStr varchar(8000)   
declare @Eq varchar(8000)   
declare @IndId int  
declare @IndStatus int  
declare @CurrIndId smallint  
declare @CurrStatus int  
declare @UKey sysname   
declare @Col varchar(128)  
declare @LastUsedCol varchar(128)  
declare @xType int  
declare @Len int  
declare @SelectStr varchar(8000)   
declare @ExecSql nvarchar(1000)   
declare @NotInDB1 bit   
declare @NotInDB2 bit   
declare @NotEq bit   
declare @Numb int  
declare @Cnt1 int  
declare @Cnt2 int  
set @Numb = 0  
  
declare @StrInd int  
declare @i int  
declare @PrintStr varchar(8000)  
declare @ExecStr varchar(8000)  
declare TabCur cursor for   
  
select d1o.name, d1u.name, d2u.name from '+@db1+'.dbo.sysobjects d1o, '+@db2+'.dbo.sysobjects d2o,  
'+@db1+'.dbo.sysusers d1u, '+@db2+'.dbo.sysusers d2u   
where d1o.name = d2o.name and d1o.type = ''U'' and d2o.type = ''U''  
and d1o.uid = d1u.uid and d2o.uid = d2u.uid   
and d1o.name not in (''dtproperties'')   
and d1o.name in (select * from #TabToCheck)  
order by 1  
  
open TabCur   
fetch next from TabCur into @Tab, @d1User, @d2User   
while @@fetch_status = 0   
begin   
set @Numb = @Numb + 1  
print Char(13)+Char(10)+LTRIM(STR(@Numb))+''. TABLE: [''+@Tab+''] ''  
  
set @ExecSql = ''SELECT @Cnt = count(*) FROM '+@db1+'.[''+@d1User+''].[''+@Tab+'']''  
exec sp_executesql @ExecSql, N''@Cnt int output'', @Cnt = @Cnt1 output  
print CHAR(10)+STR(@Cnt1)+'' rows in '+@db1+'''  
set @ExecSql = ''SELECT @Cnt = count(*) FROM '+@db2+'.[''+@d2User+''].[''+@Tab+'']''  
exec sp_executesql @ExecSql, N''@Cnt int output'', @Cnt = @Cnt2 output  
print STR(@Cnt2)+'' rows in '+@db2+'''  
if @Cnt1 = 0 and @Cnt2 = 0  
begin  
exec ('' insert into #EmptyTables values(''''[''+@Tab+'']'''')'')   
goto NextTab  
end  
set @KeyAndStr = ''''   
set @KeyCommaStr = ''''   
set @NotInDB1 = 0  
set @NotInDB2 = 0   
set @NotEq = 0  
set @KeyAndStr = ''''   
set @KeyCommaStr = ''''   
truncate table #IndList1  
declare UKeys cursor fast_forward for   
select i.indid, i.status, c.name, c.xType from '+@db1+'.dbo.sysobjects o, '+@db1+'.dbo.sysindexes i, '+@db1+'.dbo.sysindexkeys k, '+@db1+'.dbo.syscolumns c   
where i.id = o.id and o.name = @Tab  
and (i.status & 2)<>0   
and k.id = o.id and k.indid = i.indid   
and c.id = o.id and c.colid = k.colid   
order by i.indid, c.name  
open UKeys   
fetch next from UKeys into @IndId, @IndStatus, @UKey, @xType  
set @CurrIndId = @IndId  
set @CurrStatus = @IndStatus  
while @@fetch_status = 0   
begin   
if @KeyAndStr <> ''''  
begin   
set @KeyAndStr = @KeyAndStr + '' and '' + CHAR(10)   
set @KeyCommaStr = @KeyCommaStr + '', ''   
end   
if @xType = 175 or @xType = 167 or @xType = 239 or @xType = 231 -- char, varchar, nchar, nvarchar  
begin  
set @KeyAndStr = @KeyAndStr + '' ISNULL(d1.[''+@UKey+''],''''!#null$'''')=ISNULL(d2.[''+@UKey+''],''''!#null$'''') ''  
end  
if @xType = 173 or @xType = 165 -- binary, varbinary  
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 56 or @xType = 127 or @xType = 60 or @xType = 122 -- int, 127 - bigint,60 - money, 122 - smallmoney  
begin  
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 971428763405345098745 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 971428763405345098745 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 106 or @xType = 108 -- int, decimal, numeric  
begin  
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 71428763405345098745098.8723 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 71428763405345098745098.8723 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 62 or @xType = 59 -- 62 - float, 59 - real  
begin   
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 8764589764.22708E237 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 8764589764.22708E237 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 52 or @xType = 48 or @xType = 104 -- smallint, tinyint, bit  
begin  
set @KeyAndStr = @KeyAndStr + '' CASE WHEN d1.[''+@UKey+''] is null THEN 99999 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 99999 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 36 -- 36 - id   
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d2.[''+@UKey+''] END''  
end  
else if @xType = 61 or @xType = 58 -- datetime, smalldatetime  
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d1.[''+@UKey+''],109) END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d2.[''+@UKey+''],109) END ''  
end  
else if @xType = 189 -- timestamp (189)   
begin  
set @KeyAndStr = @KeyAndStr + '' d1.[''+@UKey+'']=d2.[''+@UKey+''] ''  
end  
else if @xType = 98 -- SQL_variant  
begin  
set @KeyAndStr = @KeyAndStr + '' ISNULL(d1.[''+@UKey+''],''''!#null$'''')=ISNULL(d2.[''+@UKey+''],''''!#null$'''') ''  
end  
set @KeyCommaStr = @KeyCommaStr + '' d1.''+@UKey   
fetch next from UKeys into @IndId, @IndStatus, @UKey, @xType  
if @IndId <> @CurrIndId  
begin  
insert into #IndList1 values (@CurrIndId, @CurrStatus, @KeyAndStr, @KeyCommaStr)  
set @CurrIndId = @IndId  
set @CurrStatus = @IndStatus  
set @KeyAndStr = ''''  
set @KeyCommaStr = ''''   
end  
end   
deallocate UKeys   
insert into #IndList1 values (@CurrIndId, @CurrStatus, @KeyAndStr, @KeyCommaStr)'  
set @SqlStrGetListOfKeys2 = '  
set @KeyAndStr = ''''   
set @KeyCommaStr = ''''   
truncate table #IndList2  
declare UKeys cursor fast_forward for   
select i.indid, i.status, c.name, c.xType from '+@db2+'.dbo.sysobjects o, '+@db2+'.dbo.sysindexes i, '+@db2+'.dbo.sysindexkeys k, '+@db2+'.dbo.syscolumns c   
where i.id = o.id and o.name = @Tab  
and (i.status & 2)<>0   
and k.id = o.id and k.indid = i.indid   
and c.id = o.id and c.colid = k.colid   
order by i.indid, c.name  
open UKeys   
fetch next from UKeys into @IndId, @IndStatus, @UKey, @xType  
set @CurrIndId = @IndId  
set @CurrStatus = @IndStatus  
while @@fetch_status = 0   
begin   
if @KeyAndStr <> ''''  
begin   
set @KeyAndStr = @KeyAndStr + '' and '' + CHAR(10)   
set @KeyCommaStr = @KeyCommaStr + '', ''   
end   
if @xType = 175 or @xType = 167 or @xType = 239 or @xType = 231 -- char, varchar, nchar, nvarchar  
begin  
set @KeyAndStr = @KeyAndStr + '' ISNULL(d1.[''+@UKey+''],''''!#null$'''')=ISNULL(d2.[''+@UKey+''],''''!#null$'''') ''  
end  
if @xType = 173 or @xType = 165 -- binary, varbinary  
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 56 or @xType = 127 or @xType = 60 or @xType = 122 -- int, 127 - bigint,60 - money, 122 - smallmoney  
begin  
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 971428763405345098745 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 971428763405345098745 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 106 or @xType = 108 -- int, decimal, numeric  
begin  
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 71428763405345098745098.8723 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 71428763405345098745098.8723 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 62 or @xType = 59 -- 62 - float, 59 - real  
begin   
set @KeyAndStr = @KeyAndStr +   
'' CASE WHEN d1.[''+@UKey+''] is null THEN 8764589764.22708E237 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 8764589764.22708E237 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 52 or @xType = 48 or @xType = 104 -- smallint, tinyint, bit  
begin  
set @KeyAndStr = @KeyAndStr + '' CASE WHEN d1.[''+@UKey+''] is null THEN 99999 ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN 99999 ELSE d2.[''+@UKey+''] END ''  
end  
else if @xType = 36 -- 36 - id   
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d1.[''+@UKey+''] END=''+  
''CASE WHEN d2.[''+@UKey+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d2.[''+@UKey+''] END''  
end  
else if @xType = 61 or @xType = 58 -- datetime, smalldatetime  
begin  
set @KeyAndStr = @KeyAndStr +  
'' CASE WHEN d1.[''+@UKey+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d1.[''+@UKey+''],109) END=''+  
''CASE WHEN d2.[''+@UKey+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d2.[''+@UKey+''],109) END ''  
end  
else if @xType = 189 -- timestamp (189)   
begin  
set @KeyAndStr = @KeyAndStr + '' d1.[''+@UKey+'']=d2.[''+@UKey+''] ''  
end  
else if @xType = 98 -- SQL_variant  
begin  
set @KeyAndStr = @KeyAndStr + '' ISNULL(d1.[''+@UKey+''],''''!#null$'''')=ISNULL(d2.[''+@UKey+''],''''!#null$'''') ''  
end  
set @KeyCommaStr = @KeyCommaStr + '' d1.''+@UKey   
fetch next from UKeys into @IndId, @IndStatus, @UKey, @xType  
if @IndId <> @CurrIndId  
begin  
insert into #IndList2 values (@CurrIndId, @CurrStatus, @KeyAndStr, @KeyCommaStr)  
set @CurrIndId = @IndId  
set @CurrStatus = @IndStatus  
set @KeyAndStr = ''''  
set @KeyCommaStr = ''''   
end  
end   
deallocate UKeys   
insert into #IndList2 values (@CurrIndId, @CurrStatus, @KeyAndStr, @KeyCommaStr)  
set @KeyCommaStr = null  
  
select @KeyCommaStr=i1.KeyCommaStr from #IndList1 i1  
join #IndList2 i2 on i1.KeyCommaStr = i2.KeyCommaStr  
where (i1.IndStatus & 2048)<> 0 and (i2.IndStatus & 2048)<>0  
  
if @KeyCommaStr is null   
set @KeyCommaStr = (select top 1 i1.KeyCommaStr from #IndList1 i1  
join #IndList2 i2 on i1.KeyCommaStr = i2.KeyCommaStr)  
set @KeyAndStr = (select TOP 1 KeyAndStr from #IndList1 where KeyCommaStr = @KeyCommaStr)  
if @KeyCommaStr is null  
set @KeyCommaStr = ''''  
if @KeyAndStr is null  
set @KeyAndStr = '''''  
set @SqlStrGetListOfColumns = '  
set @AndStr = ''''  
set @StrInd = 1  
declare Cols cursor local fast_forward for   
select c.name, c.xtype, c.length from '+@db1+'.dbo.sysobjects o, '+@db1+'.dbo.syscolumns c  
where o.id = c.id and o.name = @Tab   
and CHARINDEX(c.name, @KeyCommaStr) = 0  
open Cols   
fetch next from Cols into @Col, @xType, @len  
while @@fetch_status = 0   
begin   
if @xType = 175 or @xType = 167 or @xType = 239 or @xType = 231 -- char, varchar, nchar, nvarchar  
begin  
set @Eq = ''ISNULL(d1.[''+@Col+''],''''!#null$'''')=ISNULL(d2.[''+@Col+''],''''!#null$'''') ''  
end  
if @xType = 173 or @xType = 165 -- binary, varbinary  
begin  
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN 0x4D4FFB23A49411D5BDDB00A0C906B7B4 ELSE d2.[''+@Col+''] END ''  
end  
else if @xType = 56 or @xType = 127 or @xType = 60 or @xType = 122 -- int, 127 - bigint,60 - money, 122 - smallmoney  
begin  
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null THEN 971428763405345098745 ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN 971428763405345098745 ELSE d2.[''+@Col+''] END ''  
end  
else if @xType = 106 or @xType = 108 -- int, decimal, numeric  
begin  
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null THEN 71428763405345098745098.8723 ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN 71428763405345098745098.8723 ELSE d2.[''+@Col+''] END ''  
end  
else if @xType = 62 or @xType = 59 -- 62 - float, 59 - real  
begin   
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null THEN 8764589764.22708E237 ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN 8764589764.22708E237 ELSE d2.[''+@Col+''] END ''  
end  
else if @xType = 52 or @xType = 48 or @xType = 104 -- smallint, tinyint, bit  
begin  
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null THEN 99999 ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN 99999 ELSE d2.[''+@Col+''] END ''  
end  
else if @xType = 36 -- 36 - id   
begin  
set @Eq = ''CASE WHEN d1.[''+@Col+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d1.[''+@Col+''] END=''+  
''CASE WHEN d2.[''+@Col+''] is null''+  
'' THEN CONVERT(uniqueidentifier,''''1CD827A0-744A-4866-8401-B9902CF2D4FB'''')''+  
'' ELSE d2.[''+@Col+''] END''  
end  
else if @xType = 61 or @xType = 58 -- datetime, smalldatetime  
begin  
set @Eq =  
''CASE WHEN d1.[''+@Col+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d1.[''+@Col+''],109) END=''+  
''CASE WHEN d2.[''+@Col+''] is null THEN ''''!#null$'''' ELSE CONVERT(varchar(40),d2.[''+@Col+''],109) END ''  
end  
else if @xType = 34  
begin  
set @Eq = ''ISNULL(DATALENGTH(d1.[''+@Col+'']),0)=ISNULL(DATALENGTH(d2.[''+@Col+'']),0) ''   
end  
else if @xType = 35 or @xType = 99 -- text (35),ntext (99)   
begin  
set @Eq = ''ISNULL(SUBSTRING(d1.[''+@Col+''],1,DATALENGTH(d1.[''+@Col+  
''])),''''!#null$'''')=ISNULL(SUBSTRING(d2.[''+@Col+''],1,DATALENGTH(d2.[''+@Col+''])),''''!#null$'''') ''  
end  
else if @xType = 189   
begin  
if '+STR(@NoTimestamp)+' = 0   
set @Eq = ''d1.[''+@Col+'']=d2.[''+@Col+''] ''  
else  
set @Eq = ''1=1''  
end  
else if @xType = 98 -- SQL_variant  
begin  
set @Eq = ''ISNULL(d1.[''+@Col+''],''''!#null$'''')=ISNULL(d2.[''+@Col+''],''''!#null$'''') ''  
end  
if @AndStr = ''''  
set @AndStr = @AndStr + CHAR(10) + '' '' + @Eq   
else  
if len(@AndStr) + len('' and '' + @Eq)<8000  
set @AndStr = @AndStr + '' and '' + CHAR(10) + '' '' + @Eq   
else  
begin  
set @StrInd = @StrInd + 1  
Insert into ##CompareStr values(@StrInd,@AndStr)  
set @AndStr = '' and '' + @Eq   
end  
fetch next from Cols into @Col, @xType, @len   
end   
deallocate Cols '  
set @SqlStrCompareUKeyTables = '  
if @KeyAndStr <> ''''  
begin  
set @SelectStr = ''SELECT ''+ @KeyCommaStr+'' INTO ##NotInDb2 FROM '+@db1+'.[''+@d1User+''].[''+@Tab+''] d1 ''+   
'' WHERE not exists''+CHAR(10)+'' (SELECT * FROM '+@db2+'.[''+@d2User+''].[''+@Tab+''] d2 ''+   
'' WHERE ''+CHAR(10)+@KeyAndStr+'')''  
if '+STR(@VerboseLevel)+' = 1  
print CHAR(10)+''To find rows that are in '+@db1+', but are not in db2:''+CHAR(10)+  
REPLACE (@SelectStr, ''into ##NotInDB2'','''')  
exec (@SelectStr)   
if @@rowcount > 0   
set @NotInDB2 = 1   
set @SelectStr = ''SELECT ''+@KeyCommaStr+'' INTO ##NotInDB1 FROM '+@db2+'.[''+@d2User+''].[''+@Tab+''] d1 ''+   
'' WHERE not exists''+CHAR(10)+'' (SELECT * FROM '+@db1+'.[''+@d1User+''].[''+@Tab+''] d2 ''+   
'' WHERE ''+CHAR(10)+@KeyAndStr+'')''   
if '+STR(@VerboseLevel)+' = 1  
print CHAR(10)+''To find rows that are in '+@db2+', but are not in '+@db1+':''+CHAR(10)+  
REPLACE (@SelectStr, ''into ##NotInDB1'','''')  
exec (@SelectStr)   
if @@rowcount > 0   
set @NotInDB1 = 1   
-- if there are non-key columns  
if @AndStr <> ''''   
begin  
set @PrintStr = '' Print ''  
set @ExecStr = '' exec (''  
set @sqlStr = ''''  
Insert into ##CompareStr values(1,  
''SELECT ''+ @KeyCommaStr+'' INTO ##NotEq FROM '+@db2+'.[''+@d2User+''].[''+@Tab+''] d1 ''+   
'' INNER JOIN '+@db1+'.[''+@d1User+''].[''+@Tab+''] d2 ON ''+CHAR(10)+@KeyAndStr+CHAR(10)+''WHERE not('')   
-- Adding last string in temp table containing a comparing string to execute  
set @StrInd = @StrInd + 1  
Insert into ##CompareStr values(@StrInd,@AndStr+'')'')  
set @i = 1  
while @i <= @StrInd  
begin  
set @sqlStr = @sqlStr + '' declare @Str''+LTRIM(STR(@i))+'' varchar(8000) ''+  
''select @Str''+LTRIM(STR(@i))+''=CompareStr FROM ##CompareStr WHERE ind = ''+STR(@i)  
if @ExecStr <> '' exec (''  
set @ExecStr = @ExecStr + ''+''  
if @PrintStr <> '' Print ''  
set @PrintStr = @PrintStr + ''+''  
set @ExecStr = @ExecStr + ''@Str''+LTRIM(STR(@i))  
set @PrintStr = @PrintStr + '' REPLACE(@Str''+LTRIM(STR(@i))+'','''' into ##NotEq'''','''''''') ''  
set @i = @i + 1  
end  
set @ExecStr = @ExecStr + '') ''  
set @ExecSqlStr = @sqlStr + @ExecStr   
set @PrintSqlStr = @sqlStr +   
'' Print CHAR(10)+''''To find rows that are different in non-key columns:'''' ''+  
@PrintStr   
if '+STR(@VerboseLevel)+' = 1  
exec (@PrintSqlStr)  
exec (@ExecSqlStr)  
  
if @@rowcount > 0   
set @NotEq = 1   
end  
else  
if '+STR(@VerboseLevel)+' = 1  
print CHAR(10)+''There are no non-key columns in the table''  
truncate table ##CompareStr  
if @NotInDB1 = 1 or @NotInDB2 = 1 or @NotEq = 1  
begin   
print CHAR(10)+''Data are different''  
if @NotInDB2 = 1 and '+STR(@NumbToShow)+' > 0  
begin  
print ''These key values exist in '+@db1+', but do not exist in '+@db2+': ''  
set @SelectStr = ''select top ''+STR('+STR(@NumbToShow)+')+'' * from ##NotInDB2''  
exec (@SelectStr)  
end  
if @NotInDB1 = 1 and '+STR(@NumbToShow)+' > 0  
begin  
print ''These key values exist in '+@db2+', but do not exist in '+@db1+': ''  
set @SelectStr = ''select top ''+STR('+STR(@NumbToShow)+')+'' * from ##NotInDB1''  
exec (@SelectStr)  
end  
if @NotEq = 1 and '+STR(@NumbToShow)+' > 0  
begin  
print ''Row(s) with these key values contain differences in non-key columns: ''  
set @SelectStr = ''select top ''+STR('+STR(@NumbToShow)+')+'' * from ##NotEq''  
exec (@SelectStr)   
end  
exec (''insert into #DiffTables values(''''[''+@Tab+'']'''')'')   
end   
else  
begin  
print CHAR(10)+''Data are identical''  
exec ('' insert into #IdenticalTables values(''''[''+@Tab+'']'''')'')   
end  
if exists (select * from tempdb.dbo.sysobjects where name like ''##NotEq%'')  
drop table ##NotEq  
end   
else '  
set @SqlStrCompareNonUKeyTables = '  
begin  
exec (''insert into #NoPKTables values(''''[''+@Tab+'']'''')'')  
set @PrintStr = '' Print ''  
set @ExecStr = '' exec (''  
set @sqlStr = ''''  
Insert into ##CompareStr values(1,  
''SELECT ''+  
'' * INTO ##NotInDB2 FROM '+@db1+'.[''+@d1User+''].[''+@Tab+''] d1 WHERE not exists ''+CHAR(10)+  
'' (SELECT * FROM '+@db2+'.[''+@d2User+''].[''+@Tab+''] d2 WHERE '')  
set @StrInd = @StrInd + 1  
Insert into ##CompareStr values(@StrInd,@AndStr+'')'')  
set @i = 1  
while @i <= @StrInd  
begin  
set @sqlStr = @sqlStr + '' declare @Str''+LTRIM(STR(@i))+'' varchar(8000) ''+  
''select @Str''+LTRIM(STR(@i))+''=CompareStr FROM ##CompareStr WHERE ind = ''+STR(@i)  
if @ExecStr <> '' exec (''  
set @ExecStr = @ExecStr + ''+''  
if @PrintStr <> '' Print ''  
set @PrintStr = @PrintStr + ''+''  
set @ExecStr = @ExecStr + ''@Str''+LTRIM(STR(@i))  
set @PrintStr = @PrintStr + '' REPLACE(@Str''+LTRIM(STR(@i))+'','''' into ##NotInDB2'''','''''''') ''  
set @i = @i + 1  
end  
set @ExecStr = @ExecStr + '') ''  
set @ExecSqlStr = @sqlStr + @ExecStr   
set @PrintSqlStr = @sqlStr +  
'' Print CHAR(10)+''''To find rows that are in '+@db1+', but are not in '+@db2+':'''' ''+  
@PrintStr   
if '+STR(@VerboseLevel)+' = 1  
exec (@PrintSqlStr)  
exec (@ExecSqlStr)  
  
if @@rowcount > 0   
set @NotInDB2 = 1   
delete from ##CompareStr where ind = 1  
set @PrintStr = '' Print ''  
set @ExecStr = '' exec (''  
set @sqlStr = ''''  
Insert into ##CompareStr values(1,  
''SELECT ''+  
'' * INTO ##NotInDB1 FROM '+@db2+'.[''+@d2User+''].[''+@Tab+''] d1 WHERE not exists ''+CHAR(10)+  
'' (SELECT * FROM '+@db1+'.[''+@d1User+''].[''+@Tab+''] d2 WHERE '')  
set @i = 1  
while @i <= @StrInd  
begin  
set @sqlStr = @sqlStr + '' declare @Str''+LTRIM(STR(@i))+'' varchar(8000) ''+  
''select @Str''+LTRIM(STR(@i))+''=CompareStr FROM ##CompareStr WHERE ind = ''+STR(@i)  
if @ExecStr <> '' exec (''  
set @ExecStr = @ExecStr + ''+''  
if @PrintStr <> '' Print ''  
set @PrintStr = @PrintStr + ''+''  
set @ExecStr = @ExecStr + ''@Str''+LTRIM(STR(@i))  
set @PrintStr = @PrintStr + '' REPLACE(@Str''+LTRIM(STR(@i))+'','''' into ##NotInDB1'''','''''''') ''  
set @i = @i + 1  
end  
set @ExecStr = @ExecStr + '') ''  
set @ExecSqlStr = @sqlStr + @ExecStr   
set @PrintSqlStr = @sqlStr +  
'' Print CHAR(10)+''''To find rows that are in '+@db2+', but are not in '+@db1+':'''' ''+  
@PrintStr   
if '+STR(@VerboseLevel)+' = 1  
exec (@PrintSqlStr)  
exec (@ExecSqlStr)  
  
if @@rowcount > 0   
set @NotInDB1 = 1   
truncate table ##CompareStr  
if @NotInDB1 = 1 or @NotInDB2 = 1  
begin   
print CHAR(10)+''Data are different''  
if @NotInDB2 = 1 and '+STR(@NumbToShow)+' > 0  
begin  
print ''The row(s) exist in '+@db1+', but do not exist in '+@db2+': ''  
set @SelectStr = ''select top ''+STR('+STR(@NumbToShow)+')+'' * from ##NotInDB2''  
exec (@SelectStr)  
end  
if @NotInDB1 = 1 and '+STR(@NumbToShow)+' > 0  
begin  
print ''The row(s) exist in '+@db2+', but do not exist in '+@db1+': ''  
set @SelectStr = ''select top ''+STR('+STR(@NumbToShow)+')+'' * from ##NotInDB1''  
exec (@SelectStr)  
end  
exec (''insert into #DiffTables values(''''[''+@Tab+'']'''')'')   
end   
else  
begin  
print CHAR(10)+''Data are identical''  
exec ('' insert into #IdenticalTables values(''''[''+@Tab+'']'''')'')   
end  
end  
if exists (select * from tempdb.dbo.sysobjects where name like ''##NotInDB1%'')  
drop table ##NotInDB1  
if exists (select * from tempdb.dbo.sysobjects where name like ''##NotInDB2%'')  
drop table ##NotInDB2  
NextTab:  
fetch next from TabCur into @Tab, @d1User, @d2User   
end   
deallocate TabCur   
'  
exec (@SqlStrGetListOfKeys1+@SqlStrGetListOfKeys2+@SqlStrGetListOfColumns+  
@SqlStrCompareUKeyTables+@SqlStrCompareNonUKeyTables)  
print ' '  
SET NOCOUNT OFF  
if (select count(*) from #NoPKTables) > 0  
begin  
select name as 'Table(s) without Unique key:' from #NoPKTables   
end  
if (select count(*) from #DiffTables) > 0  
begin  
select name as 'Table(s) with the same name & structure, but different data:' from #DiffTables   
end  
else  
print CHAR(10)+'No tables with the same name & structure, but different data'+CHAR(10)  
if (select count(*) from #IdenticalTables) > 0  
begin  
select name as 'Table(s) with the same name & structure and identical data:' from #IdenticalTables   
end  
if (select count(*) from #EmptyTables) > 0  
begin  
select name as 'Table(s) with the same name & structure and empty in the both databases:' from #EmptyTables   
end  
drop table #TabToCheck  
drop table ##CompareStr  
drop table #DiffTables  
drop table #IdenticalTables  
drop table #EmptyTables  
drop table #NoPKTables  
drop table #IndList1  
drop table #IndList2  
return  
  


  -------------------------------

go
use master
go



create procedure spu_Kill_Users (@DBName varchar(30)) as  
--   
Declare @LoginName   varchar(30)  
Declare @QualDB      varchar(30)  
Declare @NumSPID     integer  
Declare @UndoFile    varchar(60)  
Declare @DeviceName  varchar(70)  
Declare @Comando     varchar(30)  
--   
Declare UsuariosAtivos Cursor For  
  select sysp.spid, sysp.loginame  
    from master..sysprocesses sysp (nolock),  
         master..sysdatabases sysdb (nolock)  
   where sysp.dbid = sysdb.dbid  
     and name = @DBName  
--  
Open UsuariosAtivos  
--  
Fetch Next from UsuariosAtivos Into @NumSPID, @LoginName  
While @@FETCH_STATUS = 0  
  Begin  
    if (Upper(@LoginName) <> 'SA') OR (Upper(@LoginName) <> 'CPD\SICLASQLSERVICE')  
      Begin  
       set @Comando = 'Kill ' + convert(varchar(4),@NumSPID) + ' -- Usu�rio: ' + @LoginName  
       print @Comando  
       set @Comando = 'Kill ' + convert(varchar(4),@NumSPID)  
       execute ( @Comando )  
      End  
    Fetch Next From UsuariosAtivos Into @NumSPID, @LoginName  
  End  
--  
Close UsuariosAtivos  
Deallocate UsuariosAtivos  
return  
go

use master
go

create procedure sp_acerta_logins
as  

-- Apos um restore utilize essa stored procedure para acertas os logins orf�os, dentro do banco de dados
-- De www.clouddbm.com Opensource Copywrited by Gilberto Rosa (gilberto.rosa@clouddbm.com)
-- Script executado em mais de 10 mil Bancos de Dados, valide seu ambiente e tenha backup

  
declare @cmd varchar(1000)  
declare cmd cursor  
   for  select 'exec sp_change_users_login ''update_one'', '''+name+''','+ ''''+name+''''   
 from sysusers u   
 where issqlrole <> 1   
 and hasdbaccess <> 0   
 and uid > 4   
 and uid < 16384   
 and exists (select 1 from master..syslogins l where u.name = l.name)  
open cmd   
fetch next from cmd into @cmd  
  
while @@fetch_status = 0  
   begin  
 exec(@cmd)  
 print @cmd     
 fetch next from cmd into @cmd  
   end  
close cmd  
deallocate cmd  

go

USE [master]
GO

/****** Object:  StoredProcedure [dbo].[sp_hexadecimal]    Script Date: 08/13/2013 15:02:59 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_hexadecimal]

    @binvalue varbinary(256),

    @hexvalue varchar (514) OUTPUT

AS

DECLARE @charvalue varchar (514)

DECLARE @i int

DECLARE @length int

DECLARE @hexstring char(16)

SELECT @charvalue = '0x'

SELECT @i = 1

SELECT @length = DATALENGTH (@binvalue)

SELECT @hexstring = '0123456789ABCDEF'

WHILE (@i <= @length)

BEGIN

  DECLARE @tempint int

  DECLARE @firstint int

  DECLARE @secondint int

  SELECT @tempint = CONVERT(int, SUBSTRING(@binvalue,@i,1))

  SELECT @firstint = FLOOR(@tempint/16)

  SELECT @secondint = @tempint - (@firstint*16)

  SELECT @charvalue = @charvalue +

    SUBSTRING(@hexstring, @firstint+1, 1) +

    SUBSTRING(@hexstring, @secondint+1, 1)

  SELECT @i = @i + 1

END

SELECT @hexvalue = @charvalue



GO


CREATE PROCEDURE sp_help_revlogin @login_name sysname = NULL AS  
DECLARE @name    sysname  
DECLARE @xstatus int  
DECLARE @binpwd  varbinary (256)  
DECLARE @txtpwd  sysname  
DECLARE @tmpstr  varchar (256)  
DECLARE @SID_varbinary varbinary(85)  
DECLARE @SID_string varchar(256)  
  
IF (@login_name IS NULL)  
  DECLARE login_curs CURSOR FOR   
    SELECT sid, name, xstatus, password FROM master..sysxlogins   
    WHERE srvid IS NULL AND name <> 'sa'  
ELSE  
  DECLARE login_curs CURSOR FOR   
    SELECT sid, name, xstatus, password FROM master..sysxlogins   
    WHERE srvid IS NULL AND name = @login_name  
OPEN login_curs   
FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd  
IF (@@fetch_status = -1)  
BEGIN  
  PRINT 'No login(s) found.'  
  CLOSE login_curs   
  DEALLOCATE login_curs   
  RETURN -1  
END  
SET @tmpstr = '/* sp_help_revlogin script '   
PRINT @tmpstr  
SET @tmpstr = '** Generated '   
  + CONVERT (varchar, GETDATE()) + ' on ' + @@SERVERNAME + ' */'  
PRINT @tmpstr  
PRINT ''  
PRINT 'DECLARE @pwd sysname'  
WHILE (@@fetch_status <> -1)  
BEGIN  
  IF (@@fetch_status <> -2)  
  BEGIN  
    PRINT ''  
    SET @tmpstr = '-- Login: ' + @name  
    PRINT @tmpstr   
    IF (@xstatus & 4) = 4  
    BEGIN -- NT authenticated account/group  
      IF (@xstatus & 1) = 1  
      BEGIN -- NT login is denied access  
        SET @tmpstr = 'EXEC master..sp_denylogin ''' + @name + ''''  
        PRINT @tmpstr   
      END  
      ELSE BEGIN -- NT login has access  
        SET @tmpstr = 'EXEC master..sp_grantlogin ''' + @name + ''''  
        PRINT @tmpstr   
      END  
    END  
    ELSE BEGIN -- SQL Server authentication  
      IF (@binpwd IS NOT NULL)  
      BEGIN -- Non-null password  
        EXEC sp_hexadecimal @binpwd, @txtpwd OUT  
        IF (@xstatus & 2048) = 2048  
          SET @tmpstr = 'SET @pwd = CONVERT (varchar(256), ' + @txtpwd + ')'  
        ELSE  
          SET @tmpstr = 'SET @pwd = CONVERT (varbinary(256), ' + @txtpwd + ')'  
        PRINT @tmpstr  
 EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT  
        SET @tmpstr = 'EXEC master..sp_addlogin ''' + @name   
          + ''', @pwd, @sid = ' + @SID_string + ', @encryptopt = '  
      END  
      ELSE BEGIN   
        -- Null password  
 EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT  
        SET @tmpstr = 'EXEC master..sp_addlogin ''' + @name   
          + ''', NULL, @sid = ' + @SID_string + ', @encryptopt = '  
      END  
      IF (@xstatus & 2048) = 2048  
        -- login upgraded from 6.5  
        SET @tmpstr = @tmpstr + '''skip_encryption_old'''   
      ELSE   
        SET @tmpstr = @tmpstr + '''skip_encryption'''  
      PRINT @tmpstr   
    END  
  END  
  FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd  
  END  
CLOSE login_curs   
DEALLOCATE login_curs   
RETURN 0  
  
go
